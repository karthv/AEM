import org.apache.sling.api.SlingHttpServletRequest;
import org.apache.sling.api.SlingHttpServletResponse;
import org.apache.sling.api.resource.Resource;
import org.apache.sling.api.servlets.SlingSafeMethodsServlet;
import org.apache.sling.api.resource.ResourceResolver;
import org.apache.sling.api.resource.ResourceResolverFactory;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import com.day.cq.dam.api.Asset;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.Servlet;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.Map;

@Component(
    service = Servlet.class,
    property = {
        "sling.servlet.methods=GET",
        "sling.servlet.paths=/bin/downloadzip"
    }
)
public class DownloadZipServlet extends SlingSafeMethodsServlet {

    private static final Logger LOGGER = LoggerFactory.getLogger(DownloadZipServlet.class);

    @Reference
    private ResourceResolverFactory resourceResolverFactory;

    @Override
    protected void doGet(SlingHttpServletRequest request, SlingHttpServletResponse response) throws ServletException, IOException {
        String fileName = request.getParameter("filename");

        try {
            // Validate filename (add logic here)
            validateFileName(fileName);

            // Use a try-with-resources to ensure proper resource closure
            try (ResourceResolver resourceResolver = resourceResolverFactory.getServiceResourceResolver(null)) {
                Resource resource = resourceResolver.getResource("/content/dam/test/" + fileName);

                if (resource != null && resource.isResourceType("dam:Asset")) {
                    // Follow best practice: Generate download URL for direct download from CDN
                    Asset asset = resource.adaptTo(Asset.class);
                    String downloadUrl = asset.getOriginal().getURL();

                    // Generate a JavaScript code snippet to initiate download and extraction in the browser
                    String jsCode = generateClientSideCode(downloadUrl);

                    // Send the JavaScript code as the response
                    response.getWriter().write(jsCode);
                    response.setContentType("application/javascript");
                } else {
                    // Handle case where the requested resource is not an asset
                    response.sendError(HttpServletResponse.SC_NOT_FOUND, "Asset not found");
                }
            }
        } catch (Exception e) {
            LOGGER.error("Error during download:", e);
            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        }
    }

    private String generateClientSideCode(String downloadUrl) {
        return "var xhr = new XMLHttpRequest();" +
               "xhr.responseType = 'blob';" +
               "xhr.onload = function() {" +
               "    var blob = xhr.response;" +
               "    var zip = new JSZip();" +
               "    zip.loadAsync(blob).then(function(zip) {" +
               "        // Handle extraction logic here" +
               "        zip.forEach(function (relativePath, file) {" +
               "            console.log('Extracted file:', relativePath);" +
               "        });" +
               "    });" +
               "};" +
               "xhr.open('GET', '" + downloadUrl + "', true);" +
               "xhr.send();";
    }

    // Implement the validateFileName method for security
    private void validateFileName(String fileName) {
        // Check for path traversal attempts and enforce allowed filename patterns
    }
}




import org.apache.sling.api.SlingHttpServletRequest;
import org.apache.sling.api.SlingHttpServletResponse;
import org.apache.sling.api.resource.Resource;
import org.apache.sling.api.servlets.SlingSafeMethodsServlet;
import org.apache.sling.api.resource.ResourceResolver;
import org.apache.sling.api.resource.ResourceResolverFactory;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import com.day.cq.dam.api.Asset;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@Component(
    service = SlingSafeMethodsServlet.class,
    property = {
        "sling.servlet.methods=GET",
        "sling.servlet.paths=/bin/downloadzip"
    }
)
public class DownloadZipServlet extends SlingSafeMethodsServlet {

    private static final Logger LOGGER = LoggerFactory.getLogger(DownloadZipServlet.class);

    @Reference
    private ResourceResolverFactory resourceResolverFactory;

    @Override
    protected void doGet(SlingHttpServletRequest request, SlingHttpServletResponse response) throws ServletException, IOException {
        String fileName = request.getParameter("filename");

        try {
            // Validate filename (add logic here)
            validateFileName(fileName);

            Map<String, Object> authInfo = new HashMap<>();
            // Add service user credentials or other authentication details to authInfo

            try (ResourceResolver resourceResolver = resourceResolverFactory.getServiceResourceResolver(authInfo)) {
                Resource resource = resourceResolver.getResource("/content/dam/test/" + fileName);

                if (resource != null && resource.isResourceType("dam:Asset")) {
                    // Follow best practice: Generate download URL for direct download from CDN
                    Asset asset = resource.adaptTo(Asset.class);
                    String cdnUrl = asset.getPath(); // Assumes AEM Cloud Service provides CDN URLs directly

                    // Set the response content type to ZIP
                    response.setContentType("application/zip");

                    // Set the response header for content disposition
                    response.setHeader("Content-Disposition", "attachment; filename=\"" + fileName + "\"");

                    // Include JSZip library in the response
                    response.getWriter().write(getJsZipScriptTag());

                    // Redirect the client to the CDN URL
                    response.sendRedirect(cdnUrl);

                    // Optionally, include JavaScript code for client-side extraction using JSZip
                    response.getWriter().write(getClientSideExtractionScript());

                } else {
                    // Handle case where the requested resource is not an asset
                    response.sendError(HttpServletResponse.SC_NOT_FOUND, "Asset not found");
                }
            }
        } catch (Exception e) {
            LOGGER.error("Error during download:", e);
            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        }
    }

    private String getJsZipScriptTag() {
        // Script tag to include JSZip library from CDN
        return "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js\"></script>\n";
    }

    private String getClientSideExtractionScript() {
        // JavaScript code to extract the ZIP file using JSZip on the client side
        return "<script>\n" +
               "var xhr = new XMLHttpRequest();\n" +
               "xhr.responseType = 'blob';\n" +
               "xhr.onload = function() {\n" +
               "    var blob = xhr.response;\n" +
               "    var zip = new JSZip();\n" +
               "    zip.loadAsync(blob).then(function(zip) {\n" +
               "        // Handle extraction logic here\n" +
               "        zip.forEach(function (relativePath, file) {\n" +
               "            console.log('Extracted file:', relativePath);\n" +
               "        });\n" +
               "    });\n" +
               "};\n" +
               "xhr.open('GET', '" + cdnUrl + "', true);\n" +
               "xhr.send();\n" +
               "</script>\n";
    }

    // Implement the validateFileName method for security
    private void validateFileName(String fileName) {
        // Check for path traversal attempts and enforce allowed filename patterns
    }
}

