# groupId to be used for newly created packages
groupId: com.example

# information about parent pom
parentPom:
  # absolute path to the parent pom file
  path: /path/to/parent/pom.xml
  # the artifactId to be set for the parent pom
  artifactId: parent-pom
  # the application title to be set for the parent pom
  appTitle: Parent Pom
  # version to be set for the parent pom
  version: 1.0.0

# information required for all and analyse packages
all:
  # prefix that is to be used to set the artifactId for all and analyse packages
  artifactId: my-aem-project
  # application title
  appTitle: My AEM Project
  # version to be set for all pom
  version: 1.0.0-SNAPSHOT

# information about projects
projects:
  -
    # absolute path to the project folder
    projectPath: /path/to/my/aem/project
    # Array of relative path(s) (w.r.t. the project folder) to the existing content package(s) that needs to be restructured.
    # NOTE : only content packages are expected here, NOT bundle/jar artifacts
    existingContentPackageFolder:
      - content/ui.apps
      - content/ui.content
    # relative path (w.r.t. the existing content package folder) to the filter.xml file
    # (If not specified, default path `/src/main/content/META-INF/vault/filter.xml` will be used.)
    relativePathToExistingFilterXml: src/main/content/META-INF/vault/filter.xml
    # relative path (w.r.t. the existing content package folder) to the jcr_root directory
    # (If not specified, default path `/src/main/content/jcr_root` will be used)
    relativePathToExistingJcrRoot: src/main/content/jcr_root
    # prefix that is to be used to set the artifactId for newly created ui.apps and ui.content packages
    artifactId: my-aem-project
    # application title
    appTitle: My AEM Project
    # application ID (will be used for config and package folder names)
    appId: my-aem-project
    # project specific version to be used for content packages
    version: 1.0.0-SNAPSHOT
    # Array of relative path(s) (w.r.t. the project folder) to the existing code bundles (will be embedded in the all package).
    coreBundles:
      - target/my-aem-project.core-1.0.0-SNAPSHOT.jar
    # OSGi config folders that need to be renamed.
    # The existing/source OSGi config folder PATH (JCR path stating from '/apps') is expected as key
    # and the replacement OSGi folder NAME is expected as value.
    osgiFoldersToRename:
      /apps/my-aem-project/config.prod: config.publish.prod
      /apps/system/config.author.dev1: config.author.dev
      /apps/system/config.author.dev2: config.author.dev
      
   
	
import com.day.cq.replication.Publication;
import com.day.cq.replication.ReplicationActionType;
import org.apache.sling.api.SlingHttpServletRequest;
import org.apache.sling.api.SlingHttpServletResponse;
import org.apache.sling.api.resource.ModifiableValueMap;
import org.apache.sling.api.resource.Resource;
import org.apache.sling.api.servlets.SlingSafeMethodsServlet;
import org.apache.sling.jcr.resource.JcrResourceResolver;
import org.apache.sling.serviceusermapping.ServiceUserMapped;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.jcr.RepositoryException;
import javax.jcr.Session;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.transaction.TransactionManager;


//final version
@Component(service = javax.servlet.Servlet.class, property = {
        "sling.servlet.paths=/rename-assets",
        "sling.servlet.methods=GET"
})
public class RenameAssetsServlet extends SlingSafeMethodsServlet {

    private static final Logger log = LoggerFactory.getLogger(RenameAssetsServlet.class);

    @Reference
    private JcrResourceResolver resourceResolver;

    @Reference
    private ServiceUserMapped serviceUserMapped;

    @Reference
    private TransactionManager transactionManager;

    @Override
    protected void doGet(SlingHttpServletRequest request, SlingHttpServletResponse response)
            throws ServletException, IOException {

        // Get parameters
        String dynamicPath = request.getParameter("dynamicPath");
        int poolSize = Integer.parseInt(request.getParameter("poolSize"));

        try {
            // Validate parameters
            if (dynamicPath == null || dynamicPath.isEmpty() || poolSize <= 0) {
                response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid parameters");
                return;
            }

            // Find all assets under the dynamic path
            List<String> assetPaths = new ArrayList<>();
            resourceResolver.findResources(dynamicPath, "dam:Asset", true).forEach(resource -> {
                assetPaths.add(resource.getPath());
            });

            // Start a transaction to ensure atomicity of operations
            transactionManager.begin();

            // Create a thread pool with a fixed number of threads
            ExecutorService executor = Executors.newFixedThreadPool(poolSize);

            // Process assets using threads
            for (String assetPath : assetPaths) {
                executor.execute(() -> {
                    try {
                        renameAndProcess(assetPath);
                    } catch (Exception e) {
                        log.error("Error processing asset: " + assetPath, e);
                    }
                });
            }

            // Shutdown the executor once all tasks are complete
            executor.shutdown();

            // Wait for all threads to finish
            while (!executor.isTerminated()) {
                // Do nothing, wait for threads to finish
            }

            // Commit transaction after successful completion of operations
            transactionManager.commit();

            // Log the result
            log.info("All assets were processed successfully.");
            sendStatusUpdate(response, "All assets were processed successfully.");

        } catch (Exception e) {
            // In case of an error, rollback the transaction to maintain data integrity
            transactionManager.rollback();

            // Log the error and return an internal server error response
            log.error("Error occurred during asset processing.", e);
            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "Internal Server Error");
        }
    }

    private void renameAndProcess(String assetPath) {
        try {
            // Get the asset resource
            Resource assetResource = resourceResolver.getResource(assetPath);

            if (assetResource != null) {
                // Get the old asset name
                String oldName = assetResource.getName();

                // Replace dots in the asset name with hyphens
                String newName = oldName.replace(".", "-");

                // Rename the asset
                ModifiableValueMap properties = assetResource.adaptTo(ModifiableValueMap.class);
                properties.put("jcr:content/jcr:title", "New Title");
                properties.put("jcr:content/jcr:description", "New Description");
                properties.put("jcr:content/metadata/dc:title", "New Title");
                properties.put("jcr:content/metadata/dc:description", "New Description");
                properties.put("jcr:content/metadata/dam:title", "New Title");
                properties.put("jcr:content/metadata/dam:description", "New Description");

                // Save the changes
                Session session = resourceResolver.adaptTo(Session.class);
                session.save();

                // Republish the page if it's already published
                serviceUserMapped.getServiceResourceResolver("cds-service-user").ifPresent(cdsResolver -> {
                    try {
                        Publication publication = cdsResolver.adaptTo(Publication.class);
                        if (publication.isPublished(assetPath)) {
                            replicator.replicate(ReplicationActionType.ACTIVATE, assetPath);
                            log.info("Page republished: " + assetPath);
                        }
                    } catch (RepositoryException e) {
                        log.error("Error republishing page: " + assetPath, e);
                    }
                });

                log.info("Asset and references updated: " + assetPath);
            }

        } catch (Exception e) {
            log.error("Error processing asset and republishing page: " + assetPath, e);
        }
    }

    private void sendStatusUpdate(SlingHttpServletResponse response, String message) throws IOException {
        response.setContentType("text/plain");
        response.getWriter().write(message);
    }
}




{
	/** The Constant serialVersionUID. */
	private static final long serialVersionUID = 1L;

	/** The Constant LOG. */
	private static final Logger LOG = LoggerFactory.getLogger(FileExporterServlet.class);

	/** The request response factory. */
	@Reference
	private transient RequestResponseFactory requestResponseFactory;

	/** The request processor. */
	@Reference
	private transient SlingRequestProcessor requestProcessor;

	@Reference
	private transient FileExporterService fileExporterService;

	/** The rejection handler. */
	transient RejectedExecutionHandlerImpl rejectionHandler = new RejectedExecutionHandlerImpl();

	/** The thread factory. */
	transient ThreadFactory threadFactory = Executors.defaultThreadFactory();

	/** The executor service. */
	ExecutorService executorService = new ThreadPoolExecutor(Runtime.getRuntime().availableProcessors(),
			Runtime.getRuntime().availableProcessors(),
			fileExporterService == null ? 0 : fileExporterService.getKeepAliveTimeThread(), TimeUnit.MILLISECONDS,
			new LinkedBlockingQueue<>(fileExporterService == null ? 10 : fileExporterService.getThreadCount()),
			threadFactory, rejectionHandler);

	/**
	 * Do get.
	 *
	 * @param request  the request
	 * @param response the response
	 * @throws ServletException the servlet exception
	 * @throws IOException      Signals that an I/O exception has occurred.
	 */
	@Override
	protected void doGet(SlingHttpServletRequest request, SlingHttpServletResponse response)
			throws ServletException, IOException {

		String url = request.getRequestPathInfo().getResourcePath() + HTML_EXTENSION;
		String pagePath = request.getRequestPathInfo().getResourcePath();
		String pageTitle = pagePath.substring(pagePath.lastIndexOf(FORWARD_SLASH) + 1);
		String pdfFileName = pageTitle + PDF_EXTENSION;
		String htmlFileName = pageTitle + HTML_EXTENSION;
		ResourceResolver resolver = request.getResourceResolver();
		HttpServletRequest httpRequest = requestResponseFactory.createRequest(HttpConstants.METHOD_GET, url);

		File outputFile = File.createTempFile(pdfFileName, null);
		File zipFile = File.createTempFile(pageTitle, ZIP_EXTENSION);

		try (FileInputStream fileInputStream = new FileInputStream(zipFile);
			 FileOutputStream fileOutputStream = new FileOutputStream(zipFile);
			 ZipOutputStream zipOutputStream = new ZipOutputStream(fileOutputStream)) {
			Future<?> future = executorService.submit(new FileExporterExecutor(htmlFileName, resolver, pageTitle,
					request, response, fileInputStream, outputFile, zipFile, pdfFileName, httpRequest, pagePath,
					zipOutputStream, requestProcessor, requestResponseFactory));
			try {
				future.get();
			} catch (InterruptedException | ExecutionException e) {
				LOG.error(" InterruptedException Exception occurred in future:: '{}' ", e.getMessage());
				Thread.currentThread().interrupt();
			}
		} catch (RejectedExecutionException e) {
			LOG.error("RejectedExecutionException Exception occurred in future:: '{}' ", e.getMessage());
		} finally {
			try {
				Files.deleteIfExists(Paths.get(zipFile.getAbsolutePath()));
				Files.deleteIfExists(Paths.get(outputFile.getAbsolutePath()));
			} catch (IOException e) {
				LOG.error("IOException occurred'{}':: ", e.getMessage());
			}
		}

	}

}



testing


import org.apache.sling.api.SlingHttpServletRequest;
import org.apache.sling.api.SlingHttpServletResponse;
import org.apache.sling.api.servlets.SlingSafeMethodsServlet;
import org.osgi.service.component.annotations.Component;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.ServletException;
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.concurrent.*;

@Component(
        immediate = true,
        service = javax.servlet.Servlet.class,
        property = {
                "sling.servlet.paths=/bin/file-exporter",
                "sling.servlet.extensions=html"
        }
)
public class FileExporterServlet extends SlingSafeMethodsServlet {

    private static final long serialVersionUID = 1L;
    private static final Logger LOG = LoggerFactory.getLogger(FileExporterServlet.class);

    @Reference
    private transient RequestResponseFactory requestResponseFactory;

    @Reference
    private transient SlingRequestProcessor requestProcessor;

    @Reference
    private transient FileExporterService fileExporterService;

    private ExecutorService executorService;

    @Activate
    protected void activate() {
        int corePoolSize = Runtime.getRuntime().availableProcessors();
        int maxPoolSize = Runtime.getRuntime().availableProcessors();
        long keepAliveTime = fileExporterService == null ? 0 : fileExporterService.getKeepAliveTimeThread();
        int queueCapacity = fileExporterService == null ? 10 : fileExporterService.getThreadCount();

        executorService = new ThreadPoolExecutor(
                corePoolSize, maxPoolSize, keepAliveTime, TimeUnit.MILLISECONDS,
                new LinkedBlockingQueue<>(queueCapacity),
                Executors.defaultThreadFactory(),
                new RejectedExecutionHandlerImpl()
        );
    }

    @Deactivate
    protected void deactivate() {
        executorService.shutdown();
    }

    @Override
    protected void doGet(SlingHttpServletRequest request, SlingHttpServletResponse response)
            throws ServletException, IOException {

        String url = request.getRequestPathInfo().getResourcePath() + ".html";
        String pagePath = request.getRequestPathInfo().getResourcePath();
        String pageTitle = pagePath.substring(pagePath.lastIndexOf('/') + 1);
        String pdfFileName = pageTitle + ".pdf";
        String htmlFileName = pageTitle + ".html";
        ResourceResolver resolver = request.getResourceResolver();
        HttpServletRequest httpRequest = requestResponseFactory.createRequest(HttpConstants.METHOD_GET, url);

        File outputFile = File.createTempFile(pdfFileName, null);
        File zipFile = File.createTempFile(pageTitle, ".zip");

        try (FileInputStream fileInputStream = new FileInputStream(zipFile);
             FileOutputStream fileOutputStream = new FileOutputStream(zipFile);
             ZipOutputStream zipOutputStream = new ZipOutputStream(fileOutputStream)) {

            CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
                new FileExporterExecutor(htmlFileName, resolver, pageTitle,
                        request, response, fileInputStream, outputFile, zipFile, pdfFileName, httpRequest, pagePath,
                        zipOutputStream, requestProcessor, requestResponseFactory
                ).run();
            }, executorService);

            // Wait for the completion of the task (optional)
            future.join();

        } catch (RejectedExecutionException e) {
            LOG.error("RejectedExecutionException Exception occurred in future:: '{}'", e.getMessage());
        } finally {
            try {
                Files.deleteIfExists(Paths.get(zipFile.getAbsolutePath()));
                Files.deleteIfExists(Paths.get(outputFile.getAbsolutePath()));
            } catch (IOException e) {
                LOG.error("IOException occurred'{}':: ", e.getMessage());
            }
        }
    }
}


	
	
	
		public static InputStream outputPDF(String htmlString, SlingHttpServletRequest request,
										ResourceResolver resourceResolver, File outputFile, String[] pageattributes) throws IOException {
		org.w3c.dom.Document pdfDocument = null;
		InputStream pdfInput = null;
		try (OutputStream fileOutputStream = new FileOutputStream(outputFile)) {
			ITextRenderer renderer = new ITextRenderer();
			// Load HTML file
			Document document = addDocumentStyle(htmlString, pageattributes);
			addAnchorLinkStyle(document, request);
			String[] removeAttribute = { "div.image-wide","video.movie__loop" };

			for (String attr : removeAttribute) {
				for (Element removeElement : document.select(attr)) {
					removeElement.remove();
				}
			}
			Elements coeElements = document.select("div[class^='codee-']");
			coeElements.removeAll(document.select("div.codee-image"));

			W3CDom w3cDom = new W3CDom();
			pdfDocument = w3cDom.fromJsoup(document);
			renderer.getSharedContext().setReplacedElementFactory(new MediaReplacedElementFactory(
					renderer.getSharedContext().getReplacedElementFactory(), resourceResolver, null));
			renderer.setDocument(pdfDocument, null);
			renderer.layout();
			renderer.createPDF(fileOutputStream);
			renderer.finishPDF();

			pdfInput = new FileInputStream(outputFile);
		} catch (Exception e) {
			LOG.error("Could not generate PDF content '{}' ", e.getMessage());
		}
		return pdfInput;
	}
	
	
	


