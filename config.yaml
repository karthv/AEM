# groupId to be used for newly created packages
groupId: com.example

# information about parent pom
parentPom:
  # absolute path to the parent pom file
  path: /path/to/parent/pom.xml
  # the artifactId to be set for the parent pom
  artifactId: parent-pom
  # the application title to be set for the parent pom
  appTitle: Parent Pom
  # version to be set for the parent pom
  version: 1.0.0

# information required for all and analyse packages
all:
  # prefix that is to be used to set the artifactId for all and analyse packages
  artifactId: my-aem-project
  # application title
  appTitle: My AEM Project
  # version to be set for all pom
  version: 1.0.0-SNAPSHOT

# information about projects
projects:
  -
    # absolute path to the project folder
    projectPath: /path/to/my/aem/project
    # Array of relative path(s) (w.r.t. the project folder) to the existing content package(s) that needs to be restructured.
    # NOTE : only content packages are expected here, NOT bundle/jar artifacts
    existingContentPackageFolder:
      - content/ui.apps
      - content/ui.content
    # relative path (w.r.t. the existing content package folder) to the filter.xml file
    # (If not specified, default path `/src/main/content/META-INF/vault/filter.xml` will be used.)
    relativePathToExistingFilterXml: src/main/content/META-INF/vault/filter.xml
    # relative path (w.r.t. the existing content package folder) to the jcr_root directory
    # (If not specified, default path `/src/main/content/jcr_root` will be used)
    relativePathToExistingJcrRoot: src/main/content/jcr_root
    # prefix that is to be used to set the artifactId for newly created ui.apps and ui.content packages
    artifactId: my-aem-project
    # application title
    appTitle: My AEM Project
    # application ID (will be used for config and package folder names)
    appId: my-aem-project
    # project specific version to be used for content packages
    version: 1.0.0-SNAPSHOT
    # Array of relative path(s) (w.r.t. the project folder) to the existing code bundles (will be embedded in the all package).
    coreBundles:
      - target/my-aem-project.core-1.0.0-SNAPSHOT.jar
    # OSGi config folders that need to be renamed.
    # The existing/source OSGi config folder PATH (JCR path stating from '/apps') is expected as key
    # and the replacement OSGi folder NAME is expected as value.
    osgiFoldersToRename:
      /apps/my-aem-project/config.prod: config.publish.prod
      /apps/system/config.author.dev1: config.author.dev
      /apps/system/config.author.dev2: config.author.dev
      
   
	
import com.day.cq.replication.Publication;
import com.day.cq.replication.ReplicationActionType;
import org.apache.sling.api.SlingHttpServletRequest;
import org.apache.sling.api.SlingHttpServletResponse;
import org.apache.sling.api.resource.ModifiableValueMap;
import org.apache.sling.api.resource.Resource;
import org.apache.sling.api.servlets.SlingSafeMethodsServlet;
import org.apache.sling.jcr.resource.JcrResourceResolver;
import org.apache.sling.serviceusermapping.ServiceUserMapped;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.jcr.RepositoryException;
import javax.jcr.Session;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.transaction.TransactionManager;


//final version
@Component(service = javax.servlet.Servlet.class, property = {
        "sling.servlet.paths=/rename-assets",
        "sling.servlet.methods=GET"
})
public class RenameAssetsServlet extends SlingSafeMethodsServlet {

    private static final Logger log = LoggerFactory.getLogger(RenameAssetsServlet.class);

    @Reference
    private JcrResourceResolver resourceResolver;

    @Reference
    private ServiceUserMapped serviceUserMapped;

    @Reference
    private TransactionManager transactionManager;

    @Override
    protected void doGet(SlingHttpServletRequest request, SlingHttpServletResponse response)
            throws ServletException, IOException {

        // Get parameters
        String dynamicPath = request.getParameter("dynamicPath");
        int poolSize = Integer.parseInt(request.getParameter("poolSize"));

        try {
            // Validate parameters
            if (dynamicPath == null || dynamicPath.isEmpty() || poolSize <= 0) {
                response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid parameters");
                return;
            }

            // Find all assets under the dynamic path
            List<String> assetPaths = new ArrayList<>();
            resourceResolver.findResources(dynamicPath, "dam:Asset", true).forEach(resource -> {
                assetPaths.add(resource.getPath());
            });

            // Start a transaction to ensure atomicity of operations
            transactionManager.begin();

            // Create a thread pool with a fixed number of threads
            ExecutorService executor = Executors.newFixedThreadPool(poolSize);

            // Process assets using threads
            for (String assetPath : assetPaths) {
                executor.execute(() -> {
                    try {
                        renameAndProcess(assetPath);
                    } catch (Exception e) {
                        log.error("Error processing asset: " + assetPath, e);
                    }
                });
            }

            // Shutdown the executor once all tasks are complete
            executor.shutdown();

            // Wait for all threads to finish
            while (!executor.isTerminated()) {
                // Do nothing, wait for threads to finish
            }

            // Commit transaction after successful completion of operations
            transactionManager.commit();

            // Log the result
            log.info("All assets were processed successfully.");
            sendStatusUpdate(response, "All assets were processed successfully.");

        } catch (Exception e) {
            // In case of an error, rollback the transaction to maintain data integrity
            transactionManager.rollback();

            // Log the error and return an internal server error response
            log.error("Error occurred during asset processing.", e);
            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "Internal Server Error");
        }
    }

    private void renameAndProcess(String assetPath) {
        try {
            // Get the asset resource
            Resource assetResource = resourceResolver.getResource(assetPath);

            if (assetResource != null) {
                // Get the old asset name
                String oldName = assetResource.getName();

                // Replace dots in the asset name with hyphens
                String newName = oldName.replace(".", "-");

                // Rename the asset
                ModifiableValueMap properties = assetResource.adaptTo(ModifiableValueMap.class);
                properties.put("jcr:content/jcr:title", "New Title");
                properties.put("jcr:content/jcr:description", "New Description");
                properties.put("jcr:content/metadata/dc:title", "New Title");
                properties.put("jcr:content/metadata/dc:description", "New Description");
                properties.put("jcr:content/metadata/dam:title", "New Title");
                properties.put("jcr:content/metadata/dam:description", "New Description");

                // Save the changes
                Session session = resourceResolver.adaptTo(Session.class);
                session.save();

                // Republish the page if it's already published
                serviceUserMapped.getServiceResourceResolver("cds-service-user").ifPresent(cdsResolver -> {
                    try {
                        Publication publication = cdsResolver.adaptTo(Publication.class);
                        if (publication.isPublished(assetPath)) {
                            replicator.replicate(ReplicationActionType.ACTIVATE, assetPath);
                            log.info("Page republished: " + assetPath);
                        }
                    } catch (RepositoryException e) {
                        log.error("Error republishing page: " + assetPath, e);
                    }
                });

                log.info("Asset and references updated: " + assetPath);
            }

        } catch (Exception e) {
            log.error("Error processing asset and republishing page: " + assetPath, e);
        }
    }

    private void sendStatusUpdate(SlingHttpServletResponse response, String message) throws IOException {
        response.setContentType("text/plain");
        response.getWriter().write(message);
    }
}




{
	/** The Constant serialVersionUID. */
	private static final long serialVersionUID = 1L;

	/** The Constant LOG. */
	private static final Logger LOG = LoggerFactory.getLogger(FileExporterServlet.class);

	/** The request response factory. */
	@Reference
	private transient RequestResponseFactory requestResponseFactory;

	/** The request processor. */
	@Reference
	private transient SlingRequestProcessor requestProcessor;

	@Reference
	private transient FileExporterService fileExporterService;

	/** The rejection handler. */
	transient RejectedExecutionHandlerImpl rejectionHandler = new RejectedExecutionHandlerImpl();

	/** The thread factory. */
	transient ThreadFactory threadFactory = Executors.defaultThreadFactory();

	/** The executor service. */
	ExecutorService executorService = new ThreadPoolExecutor(Runtime.getRuntime().availableProcessors(),
			Runtime.getRuntime().availableProcessors(),
			fileExporterService == null ? 0 : fileExporterService.getKeepAliveTimeThread(), TimeUnit.MILLISECONDS,
			new LinkedBlockingQueue<>(fileExporterService == null ? 10 : fileExporterService.getThreadCount()),
			threadFactory, rejectionHandler);

	/**
	 * Do get.
	 *
	 * @param request  the request
	 * @param response the response
	 * @throws ServletException the servlet exception
	 * @throws IOException      Signals that an I/O exception has occurred.
	 */
	@Override
	protected void doGet(SlingHttpServletRequest request, SlingHttpServletResponse response)
			throws ServletException, IOException {

		String url = request.getRequestPathInfo().getResourcePath() + HTML_EXTENSION;
		String pagePath = request.getRequestPathInfo().getResourcePath();
		String pageTitle = pagePath.substring(pagePath.lastIndexOf(FORWARD_SLASH) + 1);
		String pdfFileName = pageTitle + PDF_EXTENSION;
		String htmlFileName = pageTitle + HTML_EXTENSION;
		ResourceResolver resolver = request.getResourceResolver();
		HttpServletRequest httpRequest = requestResponseFactory.createRequest(HttpConstants.METHOD_GET, url);

		File outputFile = File.createTempFile(pdfFileName, null);
		File zipFile = File.createTempFile(pageTitle, ZIP_EXTENSION);

		try (FileInputStream fileInputStream = new FileInputStream(zipFile);
			 FileOutputStream fileOutputStream = new FileOutputStream(zipFile);
			 ZipOutputStream zipOutputStream = new ZipOutputStream(fileOutputStream)) {
			Future<?> future = executorService.submit(new FileExporterExecutor(htmlFileName, resolver, pageTitle,
					request, response, fileInputStream, outputFile, zipFile, pdfFileName, httpRequest, pagePath,
					zipOutputStream, requestProcessor, requestResponseFactory));
			try {
				future.get();
			} catch (InterruptedException | ExecutionException e) {
				LOG.error(" InterruptedException Exception occurred in future:: '{}' ", e.getMessage());
				Thread.currentThread().interrupt();
			}
		} catch (RejectedExecutionException e) {
			LOG.error("RejectedExecutionException Exception occurred in future:: '{}' ", e.getMessage());
		} finally {
			try {
				Files.deleteIfExists(Paths.get(zipFile.getAbsolutePath()));
				Files.deleteIfExists(Paths.get(outputFile.getAbsolutePath()));
			} catch (IOException e) {
				LOG.error("IOException occurred'{}':: ", e.getMessage());
			}
		}

	}

}



testing


import org.apache.sling.api.SlingHttpServletRequest;
import org.apache.sling.api.SlingHttpServletResponse;
import org.apache.sling.api.servlets.SlingSafeMethodsServlet;
import org.osgi.service.component.annotations.Component;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.ServletException;
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.concurrent.*;

@Component(
        immediate = true,
        service = javax.servlet.Servlet.class,
        property = {
                "sling.servlet.paths=/bin/file-exporter",
                "sling.servlet.extensions=html"
        }
)
public class FileExporterServlet extends SlingSafeMethodsServlet {

    private static final long serialVersionUID = 1L;
    private static final Logger LOG = LoggerFactory.getLogger(FileExporterServlet.class);

    @Reference
    private transient RequestResponseFactory requestResponseFactory;

    @Reference
    private transient SlingRequestProcessor requestProcessor;

    @Reference
    private transient FileExporterService fileExporterService;

    private ExecutorService executorService;

    @Activate
    protected void activate() {
        int corePoolSize = Runtime.getRuntime().availableProcessors();
        int maxPoolSize = Runtime.getRuntime().availableProcessors();
        long keepAliveTime = fileExporterService == null ? 0 : fileExporterService.getKeepAliveTimeThread();
        int queueCapacity = fileExporterService == null ? 10 : fileExporterService.getThreadCount();

        executorService = new ThreadPoolExecutor(
                corePoolSize, maxPoolSize, keepAliveTime, TimeUnit.MILLISECONDS,
                new LinkedBlockingQueue<>(queueCapacity),
                Executors.defaultThreadFactory(),
                new RejectedExecutionHandlerImpl()
        );
    }

    @Deactivate
    protected void deactivate() {
        executorService.shutdown();
    }

    @Override
    protected void doGet(SlingHttpServletRequest request, SlingHttpServletResponse response)
            throws ServletException, IOException {

        String url = request.getRequestPathInfo().getResourcePath() + ".html";
        String pagePath = request.getRequestPathInfo().getResourcePath();
        String pageTitle = pagePath.substring(pagePath.lastIndexOf('/') + 1);
        String pdfFileName = pageTitle + ".pdf";
        String htmlFileName = pageTitle + ".html";
        ResourceResolver resolver = request.getResourceResolver();
        HttpServletRequest httpRequest = requestResponseFactory.createRequest(HttpConstants.METHOD_GET, url);

        File outputFile = File.createTempFile(pdfFileName, null);
        File zipFile = File.createTempFile(pageTitle, ".zip");

        try (FileInputStream fileInputStream = new FileInputStream(zipFile);
             FileOutputStream fileOutputStream = new FileOutputStream(zipFile);
             ZipOutputStream zipOutputStream = new ZipOutputStream(fileOutputStream)) {

            CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
                new FileExporterExecutor(htmlFileName, resolver, pageTitle,
                        request, response, fileInputStream, outputFile, zipFile, pdfFileName, httpRequest, pagePath,
                        zipOutputStream, requestProcessor, requestResponseFactory
                ).run();
            }, executorService);

            // Wait for the completion of the task (optional)
            future.join();

        } catch (RejectedExecutionException e) {
            LOG.error("RejectedExecutionException Exception occurred in future:: '{}'", e.getMessage());
        } finally {
            try {
                Files.deleteIfExists(Paths.get(zipFile.getAbsolutePath()));
                Files.deleteIfExists(Paths.get(outputFile.getAbsolutePath()));
            } catch (IOException e) {
                LOG.error("IOException occurred'{}':: ", e.getMessage());
            }
        }
    }
}


	
	
	
		public static InputStream outputPDF(String htmlString, SlingHttpServletRequest request,
										ResourceResolver resourceResolver, File outputFile, String[] pageattributes) throws IOException {
		org.w3c.dom.Document pdfDocument = null;
		InputStream pdfInput = null;
		try (OutputStream fileOutputStream = new FileOutputStream(outputFile)) {
			ITextRenderer renderer = new ITextRenderer();
			// Load HTML file
			Document document = addDocumentStyle(htmlString, pageattributes);
			addAnchorLinkStyle(document, request);
			String[] removeAttribute = { "div.image-wide","video.movie__loop" };

			for (String attr : removeAttribute) {
				for (Element removeElement : document.select(attr)) {
					removeElement.remove();
				}
			}
			Elements coeElements = document.select("div[class^='codee-']");
			coeElements.removeAll(document.select("div.codee-image"));

			W3CDom w3cDom = new W3CDom();
			pdfDocument = w3cDom.fromJsoup(document);
			renderer.getSharedContext().setReplacedElementFactory(new MediaReplacedElementFactory(
					renderer.getSharedContext().getReplacedElementFactory(), resourceResolver, null));
			renderer.setDocument(pdfDocument, null);
			renderer.layout();
			renderer.createPDF(fileOutputStream);
			renderer.finishPDF();

			pdfInput = new FileInputStream(outputFile);
		} catch (Exception e) {
			LOG.error("Could not generate PDF content '{}' ", e.getMessage());
		}
		return pdfInput;
	}




 import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.bootstrap.DOMImplementationRegistry;
import org.w3c.dom.ls.DOMImplementationLS;
import org.w3c.dom.ls.LSSerializer;

import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.io.IOException;
import java.io.StringReader;
import java.io.StringWriter;

// ...

public InputStream generatePdf(String htmlString, SlingHttpServletRequest request,
                               ResourceResolver resourceResolver, File outputFile, String[] pageAttributes) {
    try (OutputStream fileOutputStream = new FileOutputStream(outputFile)) {
        ITextRenderer renderer = new ITextRenderer();

        // Load HTML file
        Document document = preprocessHtml(htmlString, request, pageAttributes);

        // Convert JSoup Document to W3C Document
        org.w3c.dom.Document pdfDocument = convertJsoupToW3CDocument(document);

        configureRenderer(renderer, resourceResolver);

        renderer.setDocument(pdfDocument, null);
        renderer.layout();
        renderer.createPDF(fileOutputStream);
        renderer.finishPDF();

        return new FileInputStream(outputFile);
    } catch (Exception e) {
        LOG.error("Error generating PDF content", e);
        // Handle the error as needed
    }

    return null;
}

private org.w3c.dom.Document convertJsoupToW3CDocument(Document jsoupDocument) throws ParserConfigurationException {
    DOMImplementationRegistry registry;
    try {
        registry = DOMImplementationRegistry.newInstance();
    } catch (Exception e) {
        throw new RuntimeException("Error initializing DOMImplementationRegistry", e);
    }

    DOMImplementationLS domImplementationLS = (DOMImplementationLS) registry.getDOMImplementation("LS");
    org.w3c.dom.Document w3cDocument = domImplementationLS.createLSInput().getCharacterStream();

    StringWriter writer = new StringWriter();
    LSSerializer lsSerializer = domImplementationLS.createLSSerializer();
    lsSerializer.write(jsoupDocument, domImplementationLS.createLSOutput().getCharacterStream());
    lsSerializer.writeToURI(jsoupDocument, domImplementationLS.createLSOutput());

    return w3cDocument;
}

  private Document preprocessHtml(String htmlString, SlingHttpServletRequest request, String[] pageAttributes) {
        Document document = Jsoup.parse(htmlString);

        // Additional preprocessing logic
        addDocumentStyle(document, pageAttributes);
        addAnchorLinkStyle(document, request);

        String[] removeAttribute = {"div.image-wide", "video.movie__loop"};

        for (String attr : removeAttribute) {
            document.select(attr).remove();
        }

        Elements coeElements = document.select("div[class^='codee-']");
        coeElements.removeAll(document.select("div.codee-image"));

        return document;
    }

    private void configureRenderer(ITextRenderer renderer, ResourceResolver resourceResolver) {
        try {
            renderer.getSharedContext().setReplacedElementFactory(new MediaReplacedElementFactory(
                    renderer.getSharedContext().getReplacedElementFactory(), resourceResolver, null));
        } catch (Exception e) {
            LOG.error("Error configuring PDF renderer", e);
        }
    }




       private org.w3c.dom.Document convertJsoupToW3CDocument(Document jsoupDocument) {
        try {
            DOMImplementationRegistry registry = DOMImplementationRegistry.newInstance();
            DOMImplementation domImpl = registry.getDOMImplementation("LS");

            DOMImplementationLS implLS = (DOMImplementationLS) domImpl.getFeature("LS", "3.0");
            LSSerializer serializer = implLS.createLSSerializer();

            org.w3c.dom.Document w3cDocument = implLS.createLSInput().getCharacterStream();
            StringWriter writer = new StringWriter();
            serializer.write(jsoupDocument, implLS.createLSOutput().getCharacterStream());
            serializer.writeToURI(jsoupDocument, implLS.createLSOutput());

            return w3cDocument;
        } catch (Exception e) {
            throw new RuntimeException("Error converting JSoup Document to W3C Document", e);
        }
    }

	final


 import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.xhtmlrenderer.pdf.ITextRenderer;
import org.thymeleaf.dom.w3c.W3CDom;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.http.HttpServletRequest;
import java.io.*;
import java.util.Arrays;

public class PdfGenerator {

    private static final Logger LOG = LoggerFactory.getLogger(PdfGenerator.class);

    public static InputStream generatePDF(String htmlString, HttpServletRequest request,
                                          ResourceResolver resourceResolver, File outputFile, String[] pageAttributes) {
        try (OutputStream fileOutputStream = new FileOutputStream(outputFile)) {
            ITextRenderer renderer = createPdfRenderer(resourceResolver);

            Document document = preprocessHtml(htmlString, request, pageAttributes);

            org.w3c.dom.Document pdfDocument = convertToW3CDocument(document);

            setRendererDocument(renderer, pdfDocument);

            renderer.createPDF(fileOutputStream);
            renderer.finishPDF();

            return new FileInputStream(outputFile);
        } catch (Exception e) {
            LOG.error("Error generating PDF content", e);
        }
        return null;
    }

    private static ITextRenderer createPdfRenderer(ResourceResolver resourceResolver) {
        ITextRenderer renderer = new ITextRenderer();
        renderer.getSharedContext().setReplacedElementFactory(new MediaReplacedElementFactory(
                renderer.getSharedContext().getReplacedElementFactory(), resourceResolver, null));
        return renderer;
    }

    private static Document preprocessHtml(String htmlString, HttpServletRequest request, String[] pageAttributes) {
        Document document = Jsoup.parse(htmlString);

        // Apply styles directly in the HTML content or add logic here

        // Remove unwanted elements
        removeElements(document, "div.image-wide", "video.movie__loop");

        // Remove codee image elements
        removeCodeeImageElements(document);

        return document;
    }

    private static void removeElements(Document document, String... selectors) {
        Arrays.stream(selectors)
                .flatMap(selector -> document.select(selector).stream())
                .forEach(Element::remove);
    }

    private static void removeCodeeImageElements(Document document) {
        Elements coeElements = document.select("div[class^='codee-']");
        coeElements.removeAll(document.select("div.codee-image"));
    }

    private static org.w3c.dom.Document convertToW3CDocument(Document document) {
        return new W3CDom().fromJsoup(document);
    }

    private static void setRendererDocument(ITextRenderer renderer, org.w3c.dom.Document pdfDocument) {
        renderer.setDocument(pdfDocument, null);
        renderer.layout();
    }
}

getstream method

public static String getRenditionUrl(Asset asset, String renditionName) {
        Rendition rendition = asset.getRendition(renditionName);
        if (rendition != null) {
            return rendition.getPath();
        } else {
            return null; // Handle the case where the rendition doesn't exist
        }
    }

    solution for this

    // Get the URL of a rendition (e.g., web rendition)
String renditionUrl = AssetUtility.getRenditionUrl(asset, "cq5dam.web.1280.1280.jpeg");


	
	public static String getDomain(SlingHttpServletRequest request) {
		String domain = "";
		Resource resource = request.getResource();
		InheritanceValueMap iProperties = new HierarchyNodeInheritanceValueMap(resource);
		domain = iProperties.getInherited("domain", "");
		if (StringUtils.isEmpty(domain)) {
			String pageURL = request.getRequestURL().toString();
			domain = StringUtils.substringBefore(pageURL, CONTENT_NODE);
		}
		return domain;
	}

 import org.apache.commons.lang3.StringUtils;
import org.apache.sling.api.SlingHttpServletRequest;
import com.day.cq.wcm.api.Page;
import com.day.cq.wcm.api.PageManager;

public class DomainUtil {

    private static final String CONTENT_NODE = "/content/";

    public static String getDomain(SlingHttpServletRequest request) {
        String domain = "";

        Resource resource = request.getResource();
        Page currentPage = resource.adaptTo(Page.class);

        if (currentPage != null) {
            domain = currentPage.getProperties().get("domain", String.class);

            if (StringUtils.isEmpty(domain)) {
                domain = getParentPageDomain(currentPage);
            }
        }

        return domain;
    }

    private static String getParentPageDomain(Page currentPage) {
        String domain = "";

        Page parentPage = currentPage.getParent();

        if (parentPage != null) {
            domain = parentPage.getProperties().get("domain", String.class);
        }

        return domain;
    }
}


public static String getDomain(SlingHttpServletRequest request) {
    String scheme = request.getScheme(); // Get the request scheme (e.g., HTTP, HTTPS)
    String serverName = request.getServerName(); // Get the server name (e.g., example.com)
    return scheme + "://" + serverName; // Combine scheme and server name to form the domain
}

public static InputStream outputPDF(String htmlString, SlingHttpServletRequest request,
                                    ResourceResolver resourceResolver, File outputFile, String[] pageAttributes) {
    try (OutputStream fileOutputStream = new FileOutputStream(outputFile)) {
        ITextRenderer renderer = new ITextRenderer();
        configureRenderer(renderer, request, resourceResolver);

        Document document = createStyledDocument(htmlString, pageAttributes, request);
        removeElements(document, "div.image-wide", "video.movie__loop");

        Elements coeElements = document.select("div[class^='codee-']");
        coeElements.removeAll(document.select("div.codee-image"));

        // Convert Jsoup Document to XHTML
        String xhtmlContent = XHTMLRendererUtil.convertToXhtml(document.html());

        // Set the XHTML content to ITextRenderer
        renderer.setDocumentFromString(xhtmlContent);

        renderer.layout();
        renderer.createPDF(fileOutputStream);
        renderer.finishPDF();

        return new FileInputStream(outputFile);
    } catch (Exception e) {
        LOG.error("Could not generate PDF content '{}'", e.getMessage());
        return null;
    }
}


testing


public static InputStream outputPDF(String htmlString, SlingHttpServletRequest request, File outputFile, String[] pageAttributes) throws IOException {
    InputStream pdfInput = null;
    try (OutputStream fileOutputStream = new FileOutputStream(outputFile)) {
        ITextRenderer renderer = new ITextRenderer();

        Document document = addDocumentStyle(htmlString, pageAttributes);
        addAnchorLinkStyle(document, request);

        String[] removeAttribute = { "div.image-wide", "video.movie__loop" };
        for (String attr : removeAttribute) {
            for (Element removeElement : document.select(attr)) {
                removeElement.remove();
            }
        }

        Elements coeElements = document.select("div[class^='codee-']");
        coeElements.removeAll(document.select("div.codee-image"));

        // Use setDocumentFromString to directly set HTML content
        renderer.setDocumentFromString(document.outerHtml());

        renderer.getSharedContext().setReplacedElementFactory(new MediaReplacedElementFactory(
                renderer.getSharedContext().getReplacedElementFactory(), request.getResourceResolver(), null));

        renderer.layout();
        renderer.createPDF(fileOutputStream);
        renderer.finishPDF();

        pdfInput = new FileInputStream(outputFile);
    } catch (Exception e) {
        LOG.error("Could not generate PDF content '{}'", e.getMessage());
    }
    return pdfInput;
}



