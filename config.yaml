import org.apache.sling.api.SlingHttpServletRequest;
import org.apache.sling.api.SlingHttpServletResponse;
import org.apache.sling.api.resource.Resource;
import org.apache.sling.api.servlets.SlingSafeMethodsServlet;
import org.apache.sling.api.resource.ResourceResolver;
import org.apache.sling.api.resource.ResourceResolverFactory;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import com.day.cq.dam.api.Asset;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.Servlet;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.Map;

@Component(
    service = Servlet.class,
    property = {
        "sling.servlet.methods=GET",
        "sling.servlet.paths=/bin/downloadzip"
    }
)
public class DownloadZipServlet extends SlingSafeMethodsServlet {

    private static final Logger LOGGER = LoggerFactory.getLogger(DownloadZipServlet.class);

    @Reference
    private ResourceResolverFactory resourceResolverFactory;

    @Override
    protected void doGet(SlingHttpServletRequest request, SlingHttpServletResponse response) throws ServletException, IOException {
        String fileName = request.getParameter("filename");

        try {
            // Validate filename (add logic here)
            validateFileName(fileName);

            // Use a try-with-resources to ensure proper resource closure
            try (ResourceResolver resourceResolver = resourceResolverFactory.getServiceResourceResolver(null)) {
                Resource resource = resourceResolver.getResource("/content/dam/test/" + fileName);

                if (resource != null && resource.isResourceType("dam:Asset")) {
                    // Follow best practice: Generate download URL for direct download from CDN
                    Asset asset = resource.adaptTo(Asset.class);
                    String downloadUrl = asset.getOriginal().getURL();

                    // Generate a JavaScript code snippet to initiate download and extraction in the browser
                    String jsCode = generateClientSideCode(downloadUrl);

                    // Send the JavaScript code as the response
                    response.getWriter().write(jsCode);
                    response.setContentType("application/javascript");
                } else {
                    // Handle case where the requested resource is not an asset
                    response.sendError(HttpServletResponse.SC_NOT_FOUND, "Asset not found");
                }
            }
        } catch (Exception e) {
            LOGGER.error("Error during download:", e);
            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        }
    }

    private String generateClientSideCode(String downloadUrl) {
        return "var xhr = new XMLHttpRequest();" +
               "xhr.responseType = 'blob';" +
               "xhr.onload = function() {" +
               "    var blob = xhr.response;" +
               "    var zip = new JSZip();" +
               "    zip.loadAsync(blob).then(function(zip) {" +
               "        // Handle extraction logic here" +
               "        zip.forEach(function (relativePath, file) {" +
               "            console.log('Extracted file:', relativePath);" +
               "        });" +
               "    });" +
               "};" +
               "xhr.open('GET', '" + downloadUrl + "', true);" +
               "xhr.send();";
    }

    // Implement the validateFileName method for security
    private void validateFileName(String fileName) {
        // Check for path traversal attempts and enforce allowed filename patterns
    }
}




import org.apache.sling.api.SlingHttpServletRequest;
import org.apache.sling.api.SlingHttpServletResponse;
import org.apache.sling.api.resource.Resource;
import org.apache.sling.api.servlets.SlingSafeMethodsServlet;
import org.apache.sling.api.resource.ResourceResolver;
import org.apache.sling.api.resource.ResourceResolverFactory;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import com.day.cq.dam.api.Asset;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@Component(
    service = SlingSafeMethodsServlet.class,
    property = {
        "sling.servlet.methods=GET",
        "sling.servlet.paths=/bin/downloadzip"
    }
)
public class DownloadZipServlet extends SlingSafeMethodsServlet {

    private static final Logger LOGGER = LoggerFactory.getLogger(DownloadZipServlet.class);

    @Reference
    private ResourceResolverFactory resourceResolverFactory;

    @Override
    protected void doGet(SlingHttpServletRequest request, SlingHttpServletResponse response) throws ServletException, IOException {
        String fileName = request.getParameter("filename");

        try {
            // Validate filename (add logic here)
            validateFileName(fileName);

            Map<String, Object> authInfo = new HashMap<>();
            // Add service user credentials or other authentication details to authInfo

            try (ResourceResolver resourceResolver = resourceResolverFactory.getServiceResourceResolver(authInfo)) {
                Resource resource = resourceResolver.getResource("/content/dam/test/" + fileName);

                if (resource != null && resource.isResourceType("dam:Asset")) {
                    // Follow best practice: Generate download URL for direct download from CDN
                    Asset asset = resource.adaptTo(Asset.class);
                    String cdnUrl = asset.getPath(); // Assumes AEM Cloud Service provides CDN URLs directly

                    // Set the response content type to ZIP
                    response.setContentType("application/zip");

                    // Set the response header for content disposition
                    response.setHeader("Content-Disposition", "attachment; filename=\"" + fileName + "\"");

                    // Include JSZip library in the response
                    response.getWriter().write(getJsZipScriptTag());

                    // Redirect the client to the CDN URL
                    response.sendRedirect(cdnUrl);

                    // Optionally, include JavaScript code for client-side extraction using JSZip
                    response.getWriter().write(getClientSideExtractionScript());

                } else {
                    // Handle case where the requested resource is not an asset
                    response.sendError(HttpServletResponse.SC_NOT_FOUND, "Asset not found");
                }
            }
        } catch (Exception e) {
            LOGGER.error("Error during download:", e);
            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        }
    }

    private String getJsZipScriptTag() {
        // Script tag to include JSZip library from CDN
        return "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js\"></script>\n";
    }

    private String getClientSideExtractionScript() {
        // JavaScript code to extract the ZIP file using JSZip on the client side
        return "<script>\n" +
               "var xhr = new XMLHttpRequest();\n" +
               "xhr.responseType = 'blob';\n" +
               "xhr.onload = function() {\n" +
               "    var blob = xhr.response;\n" +
               "    var zip = new JSZip();\n" +
               "    zip.loadAsync(blob).then(function(zip) {\n" +
               "        // Handle extraction logic here\n" +
               "        zip.forEach(function (relativePath, file) {\n" +
               "            console.log('Extracted file:', relativePath);\n" +
               "        });\n" +
               "    });\n" +
               "};\n" +
               "xhr.open('GET', '" + cdnUrl + "', true);\n" +
               "xhr.send();\n" +
               "</script>\n";
    }

    // Implement the validateFileName method for security
    private void validateFileName(String fileName) {
        // Check for path traversal attempts and enforce allowed filename patterns
    }
}

Testing Purpose:

import org.apache.sling.api.SlingHttpServletRequest;
import org.apache.sling.api.SlingHttpServletResponse;
import org.apache.sling.api.resource.Resource;
import org.apache.sling.api.servlets.SlingSafeMethodsServlet;
import org.apache.sling.api.resource.ResourceResolver;
import org.apache.sling.api.resource.ResourceResolverFactory;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import com.day.cq.dam.api.Asset;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@Component(
    service = SlingSafeMethodsServlet.class,
    property = {
        "sling.servlet.methods=GET",
        "sling.servlet.paths=/bin/downloadzip"
    }
)
public class DownloadZipServlet extends SlingSafeMethodsServlet {

    private static final Logger LOGGER = LoggerFactory.getLogger(DownloadZipServlet.class);

    @Reference
    private ResourceResolverFactory resourceResolverFactory;

    @Override
    protected void doGet(SlingHttpServletRequest request, SlingHttpServletResponse response) throws ServletException, IOException {
        String fileName = request.getParameter("filename");

        try {
            // Validate filename (add logic here)
            validateFileName(fileName);

            Map<String, Object> authInfo = new HashMap<>();
            // Add service user credentials or other authentication details to authInfo

            try (ResourceResolver resourceResolver = resourceResolverFactory.getServiceResourceResolver(authInfo)) {
                Resource resource = resourceResolver.getResource("/content/dam/test/" + fileName);

                if (resource != null && resource.isResourceType("dam:Asset")) {
                    // Follow best practice: Generate download URL for direct download from CDN
                    Asset asset = resource.adaptTo(Asset.class);
                    String cdnUrl = asset.getPath(); // Assumes AEM Cloud Service provides CDN URLs directly

                    // Set the response content type to ZIP
                    response.setContentType("application/zip");

                    // Set the response header for content disposition
                    response.setHeader("Content-Disposition", "attachment; filename=\"" + fileName + "\"");

                    // Include JSZip library in the response
                    response.getWriter().write(getJsZipScriptTag());

                    // Redirect the client to the CDN URL
                    response.sendRedirect(cdnUrl);

                    // Include JavaScript code for client-side download, storage, and extraction
                    response.getWriter().write(getClientSideExtractionScript(cdnUrl));

                } else {
                    // Handle case where the requested resource is not an asset
                    response.sendError(HttpServletResponse.SC_NOT_FOUND, "Asset not found");
                }
            }
        } catch (Exception e) {
            LOGGER.error("Error during download:", e);
            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        }
    }

    private String getJsZipScriptTag() {
        // Script tag to include JSZip library from CDN with cache headers
        return "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js\"" +
               " integrity=\"sha512-your-integrity-hash\"" +
               " crossorigin=\"anonymous\"" +
               " integrity=\"sha512-your-integrity-hash\"" +
               " crossorigin=\"anonymous\"" +
               " referrerpolicy=\"no-referrer\"" +
               " defer></script>\n";
    }

    private String getClientSideExtractionScript(String downloadUrl) {
        // JavaScript code to download, store, and extract the ZIP file
        return "<script>\n" +
               "function downloadAndStoreZip(downloadUrl) {\n" +
               "    var xhr = new XMLHttpRequest();\n" +
               "    xhr.responseType = 'blob';\n" +
               "    xhr.onload = function() {\n" +
               "        var blob = xhr.response;\n" +
               "        var reader = new FileReader();\n" +
               "        reader.onload = function() {\n" +
               "            var binaryData = reader.result;\n" +
               "            sessionStorage.setItem('zipData', binaryData);\n" +
               "            console.log('ZIP file stored in sessionStorage');\n" +
               "            extractZipFromSessionStorage();\n" +
               "        };\n" +
               "        reader.readAsDataURL(blob);\n" +
               "    };\n" +
               "    xhr.open('GET', downloadUrl, true);\n" +
               "    xhr.send();\n" +
               "}\n" +
               "function extractZipFromSessionStorage() {\n" +
               "    var zipData = sessionStorage.getItem('zipData');\n" +
               "    var zip = new JSZip();\n" +
               "    zip.loadAsync(zipData).then(function(zip) {\n" +
               "        // Handle extraction logic here\n" +
               "        zip.forEach(function (relativePath, file) {\n" +
               "            console.log('Extracted file:', relativePath);\n" +
               "        });\n" +
               "    });\n" +
               "}\n" +
               "downloadAndStoreZip('" + downloadUrl + "');\n" +
               "</script>\n";
    }

    // Implement the validateFileName method for security
    private void validateFileName(String fileName) {
        // Check for path traversal attempts and enforce allowed filename patterns
    }
}

background download

import org.apache.sling.api.SlingHttpServletRequest;
import org.apache.sling.api.SlingHttpServletResponse;
import org.apache.sling.api.resource.Resource;
import org.apache.sling.api.servlets.SlingSafeMethodsServlet;
import org.apache.sling.api.resource.ResourceResolver;
import org.apache.sling.api.resource.ResourceResolverFactory;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import com.day.cq.dam.api.Asset;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@Component(
    service = SlingSafeMethodsServlet.class,
    property = {
        "sling.servlet.methods=GET",
        "sling.servlet.paths=/bin/downloadzip"
    }
)
public class DownloadZipServlet extends SlingSafeMethodsServlet {

    private static final Logger LOGGER = LoggerFactory.getLogger(DownloadZipServlet.class);

    @Reference
    private ResourceResolverFactory resourceResolverFactory;

    @Override
    protected void doGet(SlingHttpServletRequest request, SlingHttpServletResponse response) throws ServletException, IOException {
        String fileName = request.getParameter("filename");

        try {
            // Validate filename (add logic here)
            validateFileName(fileName);

            Map<String, Object> authInfo = new HashMap<>();
            // Add service user credentials or other authentication details to authInfo

            try (ResourceResolver resourceResolver = resourceResolverFactory.getServiceResourceResolver(authInfo)) {
                Resource resource = resourceResolver.getResource("/content/dam/test/" + fileName);

                if (resource != null && resource.isResourceType("dam:Asset")) {
                    // Follow best practice: Generate download URL for direct download from CDN
                    Asset asset = resource.adaptTo(Asset.class);
                    String cdnUrl = asset.getPath(); // Assumes AEM Cloud Service provides CDN URLs directly

                    // Set the response content type to application/octet-stream
                    response.setContentType("application/octet-stream");

                    // Set the response header for content disposition with inline type
                    response.setHeader("Content-Disposition", "inline; filename=\"" + fileName + "\"");

                    // Include JSZip library in the response
                    response.getWriter().write(getJsZipScriptTag());

                    // Include JavaScript code for client-side download, storage, and extraction
                    response.getWriter().write(getClientSideExtractionScript(cdnUrl));

                } else {
                    // Handle case where the requested resource is not an asset
                    response.sendError(HttpServletResponse.SC_NOT_FOUND, "Asset not found");
                }
            }
        } catch (Exception e) {
            LOGGER.error("Error during download:", e);
            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        }
    }

    // Implement the validateFileName method for security
    private void validateFileName(String fileName) {
        // Check for path traversal attempts and enforce allowed filename patterns
    }

    private String getJsZipScriptTag() {
        // Script tag to include JSZip library from CDN with cache headers
        return "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js\"" +
               " integrity=\"sha512-your-integrity-hash\"" +
               " crossorigin=\"anonymous\"" +
               " integrity=\"sha512-your-integrity-hash\"" +
               " crossorigin=\"anonymous\"" +
               " referrerpolicy=\"no-referrer\"" +
               " defer></script>\n";
    }

    private String getClientSideExtractionScript(String downloadUrl) {
        // JavaScript code to download, store, and extract the ZIP file in the background
        return "<script>\n" +
               "function downloadAndStoreZip(downloadUrl) {\n" +
               "    fetch(downloadUrl)\n" +
               "        .then(response => response.blob())\n" +
               "        .then(blob => {\n" +
               "            var reader = new FileReader();\n" +
               "            reader.onload = function() {\n" +
               "                var binaryData = reader.result;\n" +
               "                sessionStorage.setItem('zipData', binaryData);\n" +
               "                console.log('ZIP file stored in sessionStorage');\n" +
               "                extractZipFromSessionStorage();\n" +
               "            };\n" +
               "            reader.readAsDataURL(blob);\n" +
               "        });\n" +
               "}\n" +
               "function extractZipFromSessionStorage() {\n" +
               "    var zipData = sessionStorage.getItem('zipData');\n" +
               "    var zip = new JSZip();\n" +
               "    zip.loadAsync(zipData).then(function(zip) {\n" +
               "        // Handle extraction logic here\n" +
               "        zip.forEach(function (relativePath, file) {\n" +
               "            console.log('Extracted file:', relativePath);\n" +
               "        });\n" +
               "    });\n" +
               "}\n" +
               "downloadAndStoreZip('" + downloadUrl + "');\n" +
               "</script>\n";
    }
}


thread solution;

public class DownloadZipServlet extends HttpServlet {

    private static final Logger logger = LoggerFactory.getLogger(DownloadZipServlet.class);

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String fileName = request.getParameter("fileName");

        if (!isValidFileName(fileName)) {
            response.sendError(HttpServletResponse.SC_BAD_REQUEST);
            return;
        }

        File zipFile = new File(zipsResourcesPath + fileName);

        if (!zipFile.exists()) {
            response.sendError(HttpServletResponse.SC_NOT_FOUND);
            return;
        }

        Thread thread = new Thread(() -> {
            try {
                try (FileInputStream fileInputStream = new FileInputStream(zipFile)) {
                    byte[] buffer = new byte[(int) zipFile.length()];
                    fileInputStream.read(buffer);

                    response.setContentType("application/zip");
                    response.addHeader("Content-Disposition", "attachment; filename=" + fileName);
                    response.setContentLength(buffer.length);

                    try (OutputStream responseOutputStream = response.getOutputStream()) {
                        responseOutputStream.write(buffer);
                    }
                }
            } catch (FileNotFoundException e) {
                logger.error("Error while locating ZIP file:", e);
                response.sendError(HttpServletResponse.SC_NOT_FOUND);
            } catch (IOException e) {
                logger.error("General I/O exception while downloading ZIP:", e);
                response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
            }
        });
        thread.start();
    }

    // ... other methods, including isValidFileName() ...
}



