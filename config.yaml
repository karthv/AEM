import org.apache.sling.api.SlingHttpServletRequest;
import org.apache.sling.api.SlingHttpServletResponse;
import org.apache.sling.api.resource.Resource;
import org.apache.sling.api.servlets.SlingSafeMethodsServlet;
import org.apache.sling.api.resource.ResourceResolver;
import org.apache.sling.api.resource.ResourceResolverFactory;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import com.day.cq.dam.api.Asset;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.Servlet;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.Map;

@Component(
    service = Servlet.class,
    property = {
        "sling.servlet.methods=GET",
        "sling.servlet.paths=/bin/downloadzip"
    }
)
public class DownloadZipServlet extends SlingSafeMethodsServlet {

    private static final Logger LOGGER = LoggerFactory.getLogger(DownloadZipServlet.class);

    @Reference
    private ResourceResolverFactory resourceResolverFactory;

    @Override
    protected void doGet(SlingHttpServletRequest request, SlingHttpServletResponse response) throws ServletException, IOException {
        String fileName = request.getParameter("filename");

        try {
            // Validate filename (add logic here)
            validateFileName(fileName);

            // Use a try-with-resources to ensure proper resource closure
            try (ResourceResolver resourceResolver = resourceResolverFactory.getServiceResourceResolver(null)) {
                Resource resource = resourceResolver.getResource("/content/dam/test/" + fileName);

                if (resource != null && resource.isResourceType("dam:Asset")) {
                    // Follow best practice: Generate download URL for direct download from CDN
                    Asset asset = resource.adaptTo(Asset.class);
                    String downloadUrl = asset.getOriginal().getURL();

                    // Generate a JavaScript code snippet to initiate download and extraction in the browser
                    String jsCode = generateClientSideCode(downloadUrl);

                    // Send the JavaScript code as the response
                    response.getWriter().write(jsCode);
                    response.setContentType("application/javascript");
                } else {
                    // Handle case where the requested resource is not an asset
                    response.sendError(HttpServletResponse.SC_NOT_FOUND, "Asset not found");
                }
            }
        } catch (Exception e) {
            LOGGER.error("Error during download:", e);
            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        }
    }

    private String generateClientSideCode(String downloadUrl) {
        return "var xhr = new XMLHttpRequest();" +
               "xhr.responseType = 'blob';" +
               "xhr.onload = function() {" +
               "    var blob = xhr.response;" +
               "    var zip = new JSZip();" +
               "    zip.loadAsync(blob).then(function(zip) {" +
               "        // Handle extraction logic here" +
               "        zip.forEach(function (relativePath, file) {" +
               "            console.log('Extracted file:', relativePath);" +
               "        });" +
               "    });" +
               "};" +
               "xhr.open('GET', '" + downloadUrl + "', true);" +
               "xhr.send();";
    }

    // Implement the validateFileName method for security
    private void validateFileName(String fileName) {
        // Check for path traversal attempts and enforce allowed filename patterns
    }
}




import org.apache.sling.api.SlingHttpServletRequest;
import org.apache.sling.api.SlingHttpServletResponse;
import org.apache.sling.api.resource.Resource;
import org.apache.sling.api.servlets.SlingSafeMethodsServlet;
import org.apache.sling.api.resource.ResourceResolver;
import org.apache.sling.api.resource.ResourceResolverFactory;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import com.day.cq.dam.api.Asset;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@Component(
    service = SlingSafeMethodsServlet.class,
    property = {
        "sling.servlet.methods=GET",
        "sling.servlet.paths=/bin/downloadzip"
    }
)
public class DownloadZipServlet extends SlingSafeMethodsServlet {

    private static final Logger LOGGER = LoggerFactory.getLogger(DownloadZipServlet.class);

    @Reference
    private ResourceResolverFactory resourceResolverFactory;

    @Override
    protected void doGet(SlingHttpServletRequest request, SlingHttpServletResponse response) throws ServletException, IOException {
        String fileName = request.getParameter("filename");

        try {
            // Validate filename (add logic here)
            validateFileName(fileName);

            Map<String, Object> authInfo = new HashMap<>();
            // Add service user credentials or other authentication details to authInfo

            try (ResourceResolver resourceResolver = resourceResolverFactory.getServiceResourceResolver(authInfo)) {
                Resource resource = resourceResolver.getResource("/content/dam/test/" + fileName);

                if (resource != null && resource.isResourceType("dam:Asset")) {
                    // Follow best practice: Generate download URL for direct download from CDN
                    Asset asset = resource.adaptTo(Asset.class);
                    String cdnUrl = asset.getPath(); // Assumes AEM Cloud Service provides CDN URLs directly

                    // Set the response content type to ZIP
                    response.setContentType("application/zip");

                    // Set the response header for content disposition
                    response.setHeader("Content-Disposition", "attachment; filename=\"" + fileName + "\"");

                    // Include JSZip library in the response
                    response.getWriter().write(getJsZipScriptTag());

                    // Redirect the client to the CDN URL
                    response.sendRedirect(cdnUrl);

                    // Optionally, include JavaScript code for client-side extraction using JSZip
                    response.getWriter().write(getClientSideExtractionScript());

                } else {
                    // Handle case where the requested resource is not an asset
                    response.sendError(HttpServletResponse.SC_NOT_FOUND, "Asset not found");
                }
            }
        } catch (Exception e) {
            LOGGER.error("Error during download:", e);
            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        }
    }

    private String getJsZipScriptTag() {
        // Script tag to include JSZip library from CDN
        return "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js\"></script>\n";
    }

    private String getClientSideExtractionScript() {
        // JavaScript code to extract the ZIP file using JSZip on the client side
        return "<script>\n" +
               "var xhr = new XMLHttpRequest();\n" +
               "xhr.responseType = 'blob';\n" +
               "xhr.onload = function() {\n" +
               "    var blob = xhr.response;\n" +
               "    var zip = new JSZip();\n" +
               "    zip.loadAsync(blob).then(function(zip) {\n" +
               "        // Handle extraction logic here\n" +
               "        zip.forEach(function (relativePath, file) {\n" +
               "            console.log('Extracted file:', relativePath);\n" +
               "        });\n" +
               "    });\n" +
               "};\n" +
               "xhr.open('GET', '" + cdnUrl + "', true);\n" +
               "xhr.send();\n" +
               "</script>\n";
    }

    // Implement the validateFileName method for security
    private void validateFileName(String fileName) {
        // Check for path traversal attempts and enforce allowed filename patterns
    }
}

Testing Purpose:

import org.apache.sling.api.SlingHttpServletRequest;
import org.apache.sling.api.SlingHttpServletResponse;
import org.apache.sling.api.resource.Resource;
import org.apache.sling.api.servlets.SlingSafeMethodsServlet;
import org.apache.sling.api.resource.ResourceResolver;
import org.apache.sling.api.resource.ResourceResolverFactory;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import com.day.cq.dam.api.Asset;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@Component(
    service = SlingSafeMethodsServlet.class,
    property = {
        "sling.servlet.methods=GET",
        "sling.servlet.paths=/bin/downloadzip"
    }
)
public class DownloadZipServlet extends SlingSafeMethodsServlet {

    private static final Logger LOGGER = LoggerFactory.getLogger(DownloadZipServlet.class);

    @Reference
    private ResourceResolverFactory resourceResolverFactory;

    @Override
    protected void doGet(SlingHttpServletRequest request, SlingHttpServletResponse response) throws ServletException, IOException {
        String fileName = request.getParameter("filename");

        try {
            // Validate filename (add logic here)
            validateFileName(fileName);

            Map<String, Object> authInfo = new HashMap<>();
            // Add service user credentials or other authentication details to authInfo

            try (ResourceResolver resourceResolver = resourceResolverFactory.getServiceResourceResolver(authInfo)) {
                Resource resource = resourceResolver.getResource("/content/dam/test/" + fileName);

                if (resource != null && resource.isResourceType("dam:Asset")) {
                    // Follow best practice: Generate download URL for direct download from CDN
                    Asset asset = resource.adaptTo(Asset.class);
                    String cdnUrl = asset.getPath(); // Assumes AEM Cloud Service provides CDN URLs directly

                    // Set the response content type to ZIP
                    response.setContentType("application/zip");

                    // Set the response header for content disposition
                    response.setHeader("Content-Disposition", "attachment; filename=\"" + fileName + "\"");

                    // Include JSZip library in the response
                    response.getWriter().write(getJsZipScriptTag());

                    // Redirect the client to the CDN URL
                    response.sendRedirect(cdnUrl);

                    // Include JavaScript code for client-side download, storage, and extraction
                    response.getWriter().write(getClientSideExtractionScript(cdnUrl));

                } else {
                    // Handle case where the requested resource is not an asset
                    response.sendError(HttpServletResponse.SC_NOT_FOUND, "Asset not found");
                }
            }
        } catch (Exception e) {
            LOGGER.error("Error during download:", e);
            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        }
    }

    private String getJsZipScriptTag() {
        // Script tag to include JSZip library from CDN with cache headers
        return "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js\"" +
               " integrity=\"sha512-your-integrity-hash\"" +
               " crossorigin=\"anonymous\"" +
               " integrity=\"sha512-your-integrity-hash\"" +
               " crossorigin=\"anonymous\"" +
               " referrerpolicy=\"no-referrer\"" +
               " defer></script>\n";
    }

    private String getClientSideExtractionScript(String downloadUrl) {
        // JavaScript code to download, store, and extract the ZIP file
        return "<script>\n" +
               "function downloadAndStoreZip(downloadUrl) {\n" +
               "    var xhr = new XMLHttpRequest();\n" +
               "    xhr.responseType = 'blob';\n" +
               "    xhr.onload = function() {\n" +
               "        var blob = xhr.response;\n" +
               "        var reader = new FileReader();\n" +
               "        reader.onload = function() {\n" +
               "            var binaryData = reader.result;\n" +
               "            sessionStorage.setItem('zipData', binaryData);\n" +
               "            console.log('ZIP file stored in sessionStorage');\n" +
               "            extractZipFromSessionStorage();\n" +
               "        };\n" +
               "        reader.readAsDataURL(blob);\n" +
               "    };\n" +
               "    xhr.open('GET', downloadUrl, true);\n" +
               "    xhr.send();\n" +
               "}\n" +
               "function extractZipFromSessionStorage() {\n" +
               "    var zipData = sessionStorage.getItem('zipData');\n" +
               "    var zip = new JSZip();\n" +
               "    zip.loadAsync(zipData).then(function(zip) {\n" +
               "        // Handle extraction logic here\n" +
               "        zip.forEach(function (relativePath, file) {\n" +
               "            console.log('Extracted file:', relativePath);\n" +
               "        });\n" +
               "    });\n" +
               "}\n" +
               "downloadAndStoreZip('" + downloadUrl + "');\n" +
               "</script>\n";
    }

    // Implement the validateFileName method for security
    private void validateFileName(String fileName) {
        // Check for path traversal attempts and enforce allowed filename patterns
    }
}

background download

import org.apache.sling.api.SlingHttpServletRequest;
import org.apache.sling.api.SlingHttpServletResponse;
import org.apache.sling.api.resource.Resource;
import org.apache.sling.api.servlets.SlingSafeMethodsServlet;
import org.apache.sling.api.resource.ResourceResolver;
import org.apache.sling.api.resource.ResourceResolverFactory;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import com.day.cq.dam.api.Asset;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@Component(
    service = SlingSafeMethodsServlet.class,
    property = {
        "sling.servlet.methods=GET",
        "sling.servlet.paths=/bin/downloadzip"
    }
)
public class DownloadZipServlet extends SlingSafeMethodsServlet {

    private static final Logger LOGGER = LoggerFactory.getLogger(DownloadZipServlet.class);

    @Reference
    private ResourceResolverFactory resourceResolverFactory;

    @Override
    protected void doGet(SlingHttpServletRequest request, SlingHttpServletResponse response) throws ServletException, IOException {
        String fileName = request.getParameter("filename");

        try {
            // Validate filename (add logic here)
            validateFileName(fileName);

            Map<String, Object> authInfo = new HashMap<>();
            // Add service user credentials or other authentication details to authInfo

            try (ResourceResolver resourceResolver = resourceResolverFactory.getServiceResourceResolver(authInfo)) {
                Resource resource = resourceResolver.getResource("/content/dam/test/" + fileName);

                if (resource != null && resource.isResourceType("dam:Asset")) {
                    // Follow best practice: Generate download URL for direct download from CDN
                    Asset asset = resource.adaptTo(Asset.class);
                    String cdnUrl = asset.getPath(); // Assumes AEM Cloud Service provides CDN URLs directly

                    // Set the response content type to application/octet-stream
                    response.setContentType("application/octet-stream");

                    // Set the response header for content disposition with inline type
                    response.setHeader("Content-Disposition", "inline; filename=\"" + fileName + "\"");

                    // Include JSZip library in the response
                    response.getWriter().write(getJsZipScriptTag());

                    // Include JavaScript code for client-side download, storage, and extraction
                    response.getWriter().write(getClientSideExtractionScript(cdnUrl));

                } else {
                    // Handle case where the requested resource is not an asset
                    response.sendError(HttpServletResponse.SC_NOT_FOUND, "Asset not found");
                }
            }
        } catch (Exception e) {
            LOGGER.error("Error during download:", e);
            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        }
    }

    // Implement the validateFileName method for security
    private void validateFileName(String fileName) {
        // Check for path traversal attempts and enforce allowed filename patterns
    }

    private String getJsZipScriptTag() {
        // Script tag to include JSZip library from CDN with cache headers
        return "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js\"" +
               " integrity=\"sha512-your-integrity-hash\"" +
               " crossorigin=\"anonymous\"" +
               " integrity=\"sha512-your-integrity-hash\"" +
               " crossorigin=\"anonymous\"" +
               " referrerpolicy=\"no-referrer\"" +
               " defer></script>\n";
    }

    private String getClientSideExtractionScript(String downloadUrl) {
        // JavaScript code to download, store, and extract the ZIP file in the background
        return "<script>\n" +
               "function downloadAndStoreZip(downloadUrl) {\n" +
               "    fetch(downloadUrl)\n" +
               "        .then(response => response.blob())\n" +
               "        .then(blob => {\n" +
               "            var reader = new FileReader();\n" +
               "            reader.onload = function() {\n" +
               "                var binaryData = reader.result;\n" +
               "                sessionStorage.setItem('zipData', binaryData);\n" +
               "                console.log('ZIP file stored in sessionStorage');\n" +
               "                extractZipFromSessionStorage();\n" +
               "            };\n" +
               "            reader.readAsDataURL(blob);\n" +
               "        });\n" +
               "}\n" +
               "function extractZipFromSessionStorage() {\n" +
               "    var zipData = sessionStorage.getItem('zipData');\n" +
               "    var zip = new JSZip();\n" +
               "    zip.loadAsync(zipData).then(function(zip) {\n" +
               "        // Handle extraction logic here\n" +
               "        zip.forEach(function (relativePath, file) {\n" +
               "            console.log('Extracted file:', relativePath);\n" +
               "        });\n" +
               "    });\n" +
               "}\n" +
               "downloadAndStoreZip('" + downloadUrl + "');\n" +
               "</script>\n";
    }
}


thread solution;

public class DownloadZipServlet extends HttpServlet {

    private static final Logger logger = LoggerFactory.getLogger(DownloadZipServlet.class);

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String fileName = request.getParameter("fileName");

        if (!isValidFileName(fileName)) {
            response.sendError(HttpServletResponse.SC_BAD_REQUEST);
            return;
        }

        File zipFile = new File(zipsResourcesPath + fileName);

        if (!zipFile.exists()) {
            response.sendError(HttpServletResponse.SC_NOT_FOUND);
            return;
        }

        Thread thread = new Thread(() -> {
            try {
                try (FileInputStream fileInputStream = new FileInputStream(zipFile)) {
                    byte[] buffer = new byte[(int) zipFile.length()];
                    fileInputStream.read(buffer);

                    response.setContentType("application/zip");
                    response.addHeader("Content-Disposition", "attachment; filename=" + fileName);
                    response.setContentLength(buffer.length);

                    try (OutputStream responseOutputStream = response.getOutputStream()) {
                        responseOutputStream.write(buffer);
                    }
                }
            } catch (FileNotFoundException e) {
                logger.error("Error while locating ZIP file:", e);
                response.sendError(HttpServletResponse.SC_NOT_FOUND);
            } catch (IOException e) {
                logger.error("General I/O exception while downloading ZIP:", e);
                response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
            }
        });
        thread.start();
    }

    // ... other methods, including isValidFileName() ...
}


output:

package com.your.package.name; // Adjust to your package

import com.day.cq.dam.api.Asset;
import com.day.cq.wcm.api.ResourceResolverFactory;
import com.day.cq.wcm.servlet.SlingSafeMethodsServlet;
import org.apache.sling.api.SlingHttpServletRequest;
import org.apache.sling.api.SlingHttpServletResponse;
import org.apache.sling.api.resource.ResourceResolver;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.ServletException;
import java.io.IOException;
import java.io.OutputStream;

@Component(service = Servlet.class, property = {
        "sling.servlet.methods=GET",
        "sling.servlet.paths=/bin/downloadzip" // Adjust the path as needed
})
public class DownloadZipServlet extends SlingSafeMethodsServlet {

    private static final Logger logger = LoggerFactory.getLogger(DownloadZipServlet.class);

    @Reference
    private ResourceResolverFactory resourceResolverFactory;

    @Override
    protected void doGet(SlingHttpServletRequest request, SlingHttpServletResponse response) throws ServletException, IOException {
        String assetName = request.getParameter("assetName"); // Get the dynamic name from the parameter

        try {
            // Validate asset name (add your logic here)

            ResourceResolver resourceResolver = resourceResolverFactory.getServiceResourceResolver(null);
            Resource assetResource = resourceResolver.getResource("/content/dam/testwork/" + assetName); // Build the complete path
            Asset asset = assetResource.adaptTo(Asset.class);

            if (asset == null || asset.getOriginal().getSize() <= 0) {
                throw new IOException("Asset not found or empty");
            }

            response.setContentType("application/zip"); // Assuming a ZIP download
            response.addHeader("Content-Disposition", "attachment; filename=" + asset.getName());
            response.setContentLength((int) asset.getOriginal().getSize());

            try (OutputStream responseOutputStream = response.getOutputStream();
                 InputStream assetStream = asset.getOriginal().getStream()) {
                // Use SlingZipUtils for extraction if needed:
                // SlingZipUtils.unzip(assetStream, responseOutputStream);

                // Direct download:
                byte[] buffer = new byte[1024];
                int bytesRead;
                while ((bytesRead = assetStream.read(buffer)) != -1) {
                    responseOutputStream.write(buffer, 0, bytesRead);
                }
            }
        } catch (Exception e) {
            logger.error("Error downloading asset:", e);
            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        }
    }
}


code with extract

package com.your.package.name; // Adjust to your package

import java.io.IOException;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import javax.jcr.RepositoryException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.sling.api.resource.Resource;
import org.apache.sling.api.resource.ResourceResolver;
import org.apache.sling.api.servlets.SlingSafeMethodsServlet;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Component(service = Servlet.class, property = {
        "sling.servlet.methods=GET",
        "sling.servlet.paths=/bin/downloadzip" // Adjust the path as needed
})
public class DownloadZipServlet extends SlingSafeMethodsServlet {

    private static final Logger logger = LoggerFactory.getLogger(DownloadZipServlet.class);

    @Reference
    private ResourceResolverFactory resourceResolverFactory;

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String assetName = request.getParameter("assetName");

        try {
            // Validate asset name (adapt according to your needs)
            if (!isValidFileName(assetName)) {
                throw new IllegalArgumentException("Invalid asset name");
            }

            ResourceResolver resourceResolver = resourceResolverFactory.getServiceResourceResolver(null);
            Resource assetResource = resourceResolver.getResource("/content/dam/testwork/" + assetName); // Build the complete path
            if (assetResource == null) {
                throw new RepositoryException("Asset not found");
            }

            Asset asset = assetResource.adaptTo(Asset.class);
            if (asset == null || asset.getOriginal().getSize() <= 0) {
                throw new IOException("Asset not found or empty");
            }

            response.setContentType("application/zip"); // Assuming a ZIP download
            response.addHeader("Content-Disposition", "attachment; filename=" + asset.getName());
            response.setContentLength((int) asset.getOriginal().getSize());

            try (ZipInputStream zipInputStream = new ZipInputStream(asset.getOriginal().getStream());
                 OutputStream responseOutputStream = response.getOutputStream()) {
                ZipEntry entry;
                while ((entry = zipInputStream.getNextEntry()) != null) {
                    if (!entry.isDirectory()) {
                        byte[] buffer = new byte[8192]; // Adjust buffer size as needed
                        int bytesRead;
                        while ((bytesRead = zipInputStream.read(buffer)) != -1) {
                            responseOutputStream.write(buffer, 0, bytesRead);
                        }
                    }
                    zipInputStream.closeEntry();
                }
            }
        } catch (Exception e) {
            logger.error("Error downloading asset:", e);
            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        }
    }

    private boolean isValidFileName(String filename) {
        // Example validation logic: only alphanumeric characters, underscore, and hyphen allowed
        return filename.matches("^[a-zA-Z0-9_-]+$");
    }
}

try tikka method for unzip:

package com.your.package.name; // Adjust to your package

import java.io.IOException;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import java.util.zip.ZipOutputStream;

import javax.jcr.RepositoryException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.sling.api.resource.Resource;
import org.apache.sling.api.resource.ResourceResolver;
import org.apache.sling.api.servlets.SlingSafeMethodsServlet;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Component(service = Servlet.class, property = {
        "sling.servlet.methods=GET",
        "sling.servlet.paths=/bin/downloadzip" // Adjust the path as needed
})
public class DownloadZipServlet extends SlingSafeMethodsServlet {

    private static final Logger logger = LoggerFactory.getLogger(DownloadZipServlet.class);

    @Reference
    private ResourceResolverFactory resourceResolverFactory;

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String assetName = request.getParameter("assetName");

        try {
            // Validate asset name (adapt according to your needs)
            if (!isValidFileName(assetName)) {
                throw new IllegalArgumentException("Invalid asset name");
            }

            ResourceResolver resourceResolver = resourceResolverFactory.getServiceResourceResolver(null);
            Resource assetResource = resourceResolver.getResource("/content/dam/testwork/" + assetName); // Build the complete path
            if (assetResource == null) {
                throw new RepositoryException("Asset not found");
            }

            Asset asset = assetResource.adaptTo(Asset.class);
            if (asset == null || asset.getOriginal().getSize() <= 0) {
                throw new IOException("Asset not found or empty");
            }

            response.setContentType("application/zip");
            response.addHeader("Content-Disposition", "attachment; filename=" + asset.getName());
            response.setContentLength((int) asset.getOriginal().getSize());

            try (ZipInputStream zipInputStream = new ZipInputStream(asset.getOriginal().getStream());
                 OutputStream responseOutputStream = response.getOutputStream();
                 ZipOutputStream zipOutputStream = new ZipOutputStream(responseOutputStream)) {
                ZipEntry entry;
                while ((entry = zipInputStream.getNextEntry()) != null) {
                    if (!entry.isDirectory()) {
                        zipOutputStream.putNextEntry(new ZipEntry(entry.getName()));
                        byte[] buffer = new byte[8192]; // Adjust buffer size as needed
                        int bytesRead;
                        while ((bytesRead = zipInputStream.read(buffer)) != -1) {
                            zipOutputStream.write(buffer, 0, bytesRead);
                        }
                        zipOutputStream.closeEntry();
                    }
                    zipInputStream.closeEntry();
                }
                zipOutputStream.finish();
            }
        } catch (Exception e) {
            logger.error("Error downloading asset:", e);
            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        }
    }

    private boolean isValidFileName(String filename) {
        // Example validation logic: only alphanumeric characters, underscore, and hyphen allowed
        return filename.matches("^[a-zA-Z0-9_-]+$");
    }
}

Testing the final code:

package com.your.package.name; // Adjust to your package

import java.io.BufferedOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import javax.jcr.RepositoryException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.sling.api.resource.Resource;
import org.apache.sling.api.resource.ResourceResolver;
import org.apache.sling.api.servlets.SlingSafeMethodsServlet;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Component(service = Servlet.class, property = {
        "sling.servlet.methods=GET",
        "sling.servlet.paths=/bin/downloadzip" // Adjust the path as needed
})
public class DownloadZipServlet extends SlingSafeMethodsServlet {

    private static final Logger logger = LoggerFactory.getLogger(DownloadZipServlet.class);

    @Reference
    private ResourceResolverFactory resourceResolverFactory;

    private static final int BUFFER_SIZE = 4096;
    private static final String BOUNDARY = "MULTIPART_BYTERANGES"; // Boundary string for directory creation

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String assetName = request.getParameter("assetName");

        try {
            // ... validation and asset retrieval ...

            response.setContentType("multipart/mixed; boundary=" + BOUNDARY); // Set content type for multi-part response

            try (ZipInputStream zipInputStream = new ZipInputStream(asset.getOriginal().getStream())) {
                ZipEntry entry;
                while ((entry = zipInputStream.getNextEntry()) != null) {
                    String entryPath = entry.getName();
                    if (!entry.isDirectory()) {
                        writeEntryContent(response, entryPath, zipInputStream);
                    } else {
                        createDirectoryInResponseStream(response, entryPath, zipInputStream);
                    }
                    zipInputStream.closeEntry();
                }
            }
        } catch (Exception e) {
            logger.error("Error downloading asset:", e);
            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        }
    }

    private void writeEntryContent(HttpServletResponse response, String entryPath, ZipInputStream zipInputStream) throws IOException {
        // Set path-aware Content-Disposition header
        response.getOutputStream().println("--" + BOUNDARY);
        response.addHeader("Content-Disposition", "attachment; filename=\"" + entryPath + "\"");

        try (OutputStream outputStream = response.getOutputStream()) {
            byte[] buffer = new byte[BUFFER_SIZE];
            int bytesRead;
            while ((bytesRead = zipInputStream.read(buffer)) != -1) {
                outputStream.write(buffer, 0, bytesRead);
            }
        }
    }

    private void createDirectoryInResponseStream(HttpServletResponse response, String entryPath, ZipInputStream zipInputStream) throws IOException {
        // Split directory path into components
        String[] pathComponents = entryPath.split("/");

        // Iterate through components and write directory headers
        for (int i = 0; i < pathComponents.length; i++) {
            String currentPath = String.join("/", Arrays.copyOfRange(pathComponents, 0, i + 1));

            response.getOutputStream().println("--" + BOUNDARY);
            response.addHeader("Content-Disposition", "attachment; filename=\"" + currentPath + "\"");
            response.addHeader("Content-Type", "application/x-directory");
            response.getOutputStream().println(); // Empty content for directory
        }
    

check this out:
// Function to store a ZIP file in IndexedDB
async function storeZipFile(zipBlob) {
  try {
    const db = await new Promise((resolve, reject) => {
      indexedDB.open("myZipStorage", 1)
        .onupgradeneeded((event) => {
          event.target.result.createObjectStore("zipFileData", { keyPath: "filename" });
        })
        .onsuccess(resolve)
        .onerror(reject);
    });
    const transaction = db.transaction("zipFileData", "readwrite");
    const store = transaction.objectStore("zipFileData");

    // Check for existing ZIP file to avoid duplicates (optional)
    const request = store.get("myZipFile.zip");
    const exists = await new Promise((resolve) => {
      request.onsuccess = () => resolve(true);
      request.onerror = () => resolve(false);
    });
    if (!exists) {
      // Add the ZIP file to the object store if it doesn't exist
      await store.add(zipBlob, "myZipFile.zip");
      console.log("ZIP file stored successfully");
    } else {
      console.log("ZIP file already exists in IndexedDB");
    }
  } catch (error) {
    console.error("Error storing ZIP file:", error);
  }
}

// Button and event listener
const downloadButton = document.getElementById("download-and-store-zip");

downloadButton.addEventListener("click", async () => {
  try {
    const response = await fetch("path/to/servlet/that/provides/zip"); // Replace with your servlet's path
    const zipBlob = await response.blob();

    // Store ZIP file in IndexedDB (if not already present)
    await storeZipFile(zipBlob);

    // Extract ZIP file contents
    const zip = new JSZip();
    await zip.loadAsync(zipBlob);

    // Access extracted files (example)
    console.log(zip.files); // Log all extracted files and metadata
    const fileContent = await zip.file("path/to/file.txt").async("text"); // Get content of a specific file
    console.log(fileContent);

    // Do something with the extracted files or content...
  } catch (error) {
    console.error("Error fetching, storing, or extracting ZIP file:", error);
    // Provide user-friendly error feedback here
  }
});


js code:

<script src="jszip.min.js"></script>
Use code with caution. Learn more
Use a Content Delivery Network (CDN):
Link to JSZip from a CDN directly in your HTML file:
HTML
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>






