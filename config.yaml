import org.apache.sling.api.SlingHttpServletRequest;
import org.apache.sling.api.SlingHttpServletResponse;
import org.apache.sling.api.resource.Resource;
import org.apache.sling.api.servlets.SlingSafeMethodsServlet;
import org.apache.sling.api.resource.ResourceResolver;
import org.apache.sling.api.resource.ResourceResolverFactory;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import com.day.cq.dam.api.Asset;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.Servlet;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.Map;

@Component(
    service = Servlet.class,
    property = {
        "sling.servlet.methods=GET",
        "sling.servlet.paths=/bin/downloadzip"
    }
)
public class DownloadZipServlet extends SlingSafeMethodsServlet {

    private static final Logger LOGGER = LoggerFactory.getLogger(DownloadZipServlet.class);

    @Reference
    private ResourceResolverFactory resourceResolverFactory;

    @Override
    protected void doGet(SlingHttpServletRequest request, SlingHttpServletResponse response) throws ServletException, IOException {
        String fileName = request.getParameter("filename");

        try {
            // Validate filename (add logic here)
            validateFileName(fileName);

            // Use a try-with-resources to ensure proper resource closure
            try (ResourceResolver resourceResolver = resourceResolverFactory.getServiceResourceResolver(null)) {
                Resource resource = resourceResolver.getResource("/content/dam/test/" + fileName);

                if (resource != null && resource.isResourceType("dam:Asset")) {
                    // Follow best practice: Generate download URL for direct download from CDN
                    Asset asset = resource.adaptTo(Asset.class);
                    String downloadUrl = asset.getOriginal().getURL();

                    // Generate a JavaScript code snippet to initiate download and extraction in the browser
                    String jsCode = generateClientSideCode(downloadUrl);

                    // Send the JavaScript code as the response
                    response.getWriter().write(jsCode);
                    response.setContentType("application/javascript");
                } else {
                    // Handle case where the requested resource is not an asset
                    response.sendError(HttpServletResponse.SC_NOT_FOUND, "Asset not found");
                }
            }
        } catch (Exception e) {
            LOGGER.error("Error during download:", e);
            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        }
    }

    private String generateClientSideCode(String downloadUrl) {
        return "var xhr = new XMLHttpRequest();" +
               "xhr.responseType = 'blob';" +
               "xhr.onload = function() {" +
               "    var blob = xhr.response;" +
               "    var zip = new JSZip();" +
               "    zip.loadAsync(blob).then(function(zip) {" +
               "        // Handle extraction logic here" +
               "        zip.forEach(function (relativePath, file) {" +
               "            console.log('Extracted file:', relativePath);" +
               "        });" +
               "    });" +
               "};" +
               "xhr.open('GET', '" + downloadUrl + "', true);" +
               "xhr.send();";
    }

    // Implement the validateFileName method for security
    private void validateFileName(String fileName) {
        // Check for path traversal attempts and enforce allowed filename patterns
    }
}




import org.apache.sling.api.SlingHttpServletRequest;
import org.apache.sling.api.SlingHttpServletResponse;
import org.apache.sling.api.resource.Resource;
import org.apache.sling.api.servlets.SlingSafeMethodsServlet;
import org.apache.sling.api.resource.ResourceResolver;
import org.apache.sling.api.resource.ResourceResolverFactory;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import com.day.cq.dam.api.Asset;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@Component(
    service = SlingSafeMethodsServlet.class,
    property = {
        "sling.servlet.methods=GET",
        "sling.servlet.paths=/bin/downloadzip"
    }
)
public class DownloadZipServlet extends SlingSafeMethodsServlet {

    private static final Logger LOGGER = LoggerFactory.getLogger(DownloadZipServlet.class);

    @Reference
    private ResourceResolverFactory resourceResolverFactory;

    @Override
    protected void doGet(SlingHttpServletRequest request, SlingHttpServletResponse response) throws ServletException, IOException {
        String fileName = request.getParameter("filename");

        try {
            // Validate filename (add logic here)
            validateFileName(fileName);

            Map<String, Object> authInfo = new HashMap<>();
            // Add service user credentials or other authentication details to authInfo

            try (ResourceResolver resourceResolver = resourceResolverFactory.getServiceResourceResolver(authInfo)) {
                Resource resource = resourceResolver.getResource("/content/dam/test/" + fileName);

                if (resource != null && resource.isResourceType("dam:Asset")) {
                    // Follow best practice: Generate download URL for direct download from CDN
                    Asset asset = resource.adaptTo(Asset.class);
                    String cdnUrl = asset.getPath(); // Assumes AEM Cloud Service provides CDN URLs directly

                    // Set the response content type to ZIP
                    response.setContentType("application/zip");

                    // Set the response header for content disposition
                    response.setHeader("Content-Disposition", "attachment; filename=\"" + fileName + "\"");

                    // Include JSZip library in the response
                    response.getWriter().write(getJsZipScriptTag());

                    // Redirect the client to the CDN URL
                    response.sendRedirect(cdnUrl);

                    // Optionally, include JavaScript code for client-side extraction using JSZip
                    response.getWriter().write(getClientSideExtractionScript());

                } else {
                    // Handle case where the requested resource is not an asset
                    response.sendError(HttpServletResponse.SC_NOT_FOUND, "Asset not found");
                }
            }
        } catch (Exception e) {
            LOGGER.error("Error during download:", e);
            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        }
    }

    private String getJsZipScriptTag() {
        // Script tag to include JSZip library from CDN
        return "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js\"></script>\n";
    }

    private String getClientSideExtractionScript() {
        // JavaScript code to extract the ZIP file using JSZip on the client side
        return "<script>\n" +
               "var xhr = new XMLHttpRequest();\n" +
               "xhr.responseType = 'blob';\n" +
               "xhr.onload = function() {\n" +
               "    var blob = xhr.response;\n" +
               "    var zip = new JSZip();\n" +
               "    zip.loadAsync(blob).then(function(zip) {\n" +
               "        // Handle extraction logic here\n" +
               "        zip.forEach(function (relativePath, file) {\n" +
               "            console.log('Extracted file:', relativePath);\n" +
               "        });\n" +
               "    });\n" +
               "};\n" +
               "xhr.open('GET', '" + cdnUrl + "', true);\n" +
               "xhr.send();\n" +
               "</script>\n";
    }

    // Implement the validateFileName method for security
    private void validateFileName(String fileName) {
        // Check for path traversal attempts and enforce allowed filename patterns
    }
}

Testing Purpose:

import org.apache.sling.api.SlingHttpServletRequest;
import org.apache.sling.api.SlingHttpServletResponse;
import org.apache.sling.api.resource.Resource;
import org.apache.sling.api.servlets.SlingSafeMethodsServlet;
import org.apache.sling.api.resource.ResourceResolver;
import org.apache.sling.api.resource.ResourceResolverFactory;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import com.day.cq.dam.api.Asset;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@Component(
    service = SlingSafeMethodsServlet.class,
    property = {
        "sling.servlet.methods=GET",
        "sling.servlet.paths=/bin/downloadzip"
    }
)
public class DownloadZipServlet extends SlingSafeMethodsServlet {

    private static final Logger LOGGER = LoggerFactory.getLogger(DownloadZipServlet.class);

    @Reference
    private ResourceResolverFactory resourceResolverFactory;

    @Override
    protected void doGet(SlingHttpServletRequest request, SlingHttpServletResponse response) throws ServletException, IOException {
        String fileName = request.getParameter("filename");

        try {
            // Validate filename (add logic here)
            validateFileName(fileName);

            Map<String, Object> authInfo = new HashMap<>();
            // Add service user credentials or other authentication details to authInfo

            try (ResourceResolver resourceResolver = resourceResolverFactory.getServiceResourceResolver(authInfo)) {
                Resource resource = resourceResolver.getResource("/content/dam/test/" + fileName);

                if (resource != null && resource.isResourceType("dam:Asset")) {
                    // Follow best practice: Generate download URL for direct download from CDN
                    Asset asset = resource.adaptTo(Asset.class);
                    String cdnUrl = asset.getPath(); // Assumes AEM Cloud Service provides CDN URLs directly

                    // Set the response content type to ZIP
                    response.setContentType("application/zip");

                    // Set the response header for content disposition
                    response.setHeader("Content-Disposition", "attachment; filename=\"" + fileName + "\"");

                    // Include JSZip library in the response
                    response.getWriter().write(getJsZipScriptTag());

                    // Redirect the client to the CDN URL
                    response.sendRedirect(cdnUrl);

                    // Include JavaScript code for client-side download, storage, and extraction
                    response.getWriter().write(getClientSideExtractionScript(cdnUrl));

                } else {
                    // Handle case where the requested resource is not an asset
                    response.sendError(HttpServletResponse.SC_NOT_FOUND, "Asset not found");
                }
            }
        } catch (Exception e) {
            LOGGER.error("Error during download:", e);
            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        }
    }

    private String getJsZipScriptTag() {
        // Script tag to include JSZip library from CDN with cache headers
        return "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js\"" +
               " integrity=\"sha512-your-integrity-hash\"" +
               " crossorigin=\"anonymous\"" +
               " integrity=\"sha512-your-integrity-hash\"" +
               " crossorigin=\"anonymous\"" +
               " referrerpolicy=\"no-referrer\"" +
               " defer></script>\n";
    }

    private String getClientSideExtractionScript(String downloadUrl) {
        // JavaScript code to download, store, and extract the ZIP file
        return "<script>\n" +
               "function downloadAndStoreZip(downloadUrl) {\n" +
               "    var xhr = new XMLHttpRequest();\n" +
               "    xhr.responseType = 'blob';\n" +
               "    xhr.onload = function() {\n" +
               "        var blob = xhr.response;\n" +
               "        var reader = new FileReader();\n" +
               "        reader.onload = function() {\n" +
               "            var binaryData = reader.result;\n" +
               "            sessionStorage.setItem('zipData', binaryData);\n" +
               "            console.log('ZIP file stored in sessionStorage');\n" +
               "            extractZipFromSessionStorage();\n" +
               "        };\n" +
               "        reader.readAsDataURL(blob);\n" +
               "    };\n" +
               "    xhr.open('GET', downloadUrl, true);\n" +
               "    xhr.send();\n" +
               "}\n" +
               "function extractZipFromSessionStorage() {\n" +
               "    var zipData = sessionStorage.getItem('zipData');\n" +
               "    var zip = new JSZip();\n" +
               "    zip.loadAsync(zipData).then(function(zip) {\n" +
               "        // Handle extraction logic here\n" +
               "        zip.forEach(function (relativePath, file) {\n" +
               "            console.log('Extracted file:', relativePath);\n" +
               "        });\n" +
               "    });\n" +
               "}\n" +
               "downloadAndStoreZip('" + downloadUrl + "');\n" +
               "</script>\n";
    }

    // Implement the validateFileName method for security
    private void validateFileName(String fileName) {
        // Check for path traversal attempts and enforce allowed filename patterns
    }
}

background download

import org.apache.sling.api.SlingHttpServletRequest;
import org.apache.sling.api.SlingHttpServletResponse;
import org.apache.sling.api.resource.Resource;
import org.apache.sling.api.servlets.SlingSafeMethodsServlet;
import org.apache.sling.api.resource.ResourceResolver;
import org.apache.sling.api.resource.ResourceResolverFactory;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import com.day.cq.dam.api.Asset;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@Component(
    service = SlingSafeMethodsServlet.class,
    property = {
        "sling.servlet.methods=GET",
        "sling.servlet.paths=/bin/downloadzip"
    }
)
public class DownloadZipServlet extends SlingSafeMethodsServlet {

    private static final Logger LOGGER = LoggerFactory.getLogger(DownloadZipServlet.class);

    @Reference
    private ResourceResolverFactory resourceResolverFactory;

    @Override
    protected void doGet(SlingHttpServletRequest request, SlingHttpServletResponse response) throws ServletException, IOException {
        String fileName = request.getParameter("filename");

        try {
            // Validate filename (add logic here)
            validateFileName(fileName);

            Map<String, Object> authInfo = new HashMap<>();
            // Add service user credentials or other authentication details to authInfo

            try (ResourceResolver resourceResolver = resourceResolverFactory.getServiceResourceResolver(authInfo)) {
                Resource resource = resourceResolver.getResource("/content/dam/test/" + fileName);

                if (resource != null && resource.isResourceType("dam:Asset")) {
                    // Follow best practice: Generate download URL for direct download from CDN
                    Asset asset = resource.adaptTo(Asset.class);
                    String cdnUrl = asset.getPath(); // Assumes AEM Cloud Service provides CDN URLs directly

                    // Set the response content type to application/octet-stream
                    response.setContentType("application/octet-stream");

                    // Set the response header for content disposition with inline type
                    response.setHeader("Content-Disposition", "inline; filename=\"" + fileName + "\"");

                    // Include JSZip library in the response
                    response.getWriter().write(getJsZipScriptTag());

                    // Include JavaScript code for client-side download, storage, and extraction
                    response.getWriter().write(getClientSideExtractionScript(cdnUrl));

                } else {
                    // Handle case where the requested resource is not an asset
                    response.sendError(HttpServletResponse.SC_NOT_FOUND, "Asset not found");
                }
            }
        } catch (Exception e) {
            LOGGER.error("Error during download:", e);
            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        }
    }

    // Implement the validateFileName method for security
    private void validateFileName(String fileName) {
        // Check for path traversal attempts and enforce allowed filename patterns
    }

    private String getJsZipScriptTag() {
        // Script tag to include JSZip library from CDN with cache headers
        return "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js\"" +
               " integrity=\"sha512-your-integrity-hash\"" +
               " crossorigin=\"anonymous\"" +
               " integrity=\"sha512-your-integrity-hash\"" +
               " crossorigin=\"anonymous\"" +
               " referrerpolicy=\"no-referrer\"" +
               " defer></script>\n";
    }

    private String getClientSideExtractionScript(String downloadUrl) {
        // JavaScript code to download, store, and extract the ZIP file in the background
        return "<script>\n" +
               "function downloadAndStoreZip(downloadUrl) {\n" +
               "    fetch(downloadUrl)\n" +
               "        .then(response => response.blob())\n" +
               "        .then(blob => {\n" +
               "            var reader = new FileReader();\n" +
               "            reader.onload = function() {\n" +
               "                var binaryData = reader.result;\n" +
               "                sessionStorage.setItem('zipData', binaryData);\n" +
               "                console.log('ZIP file stored in sessionStorage');\n" +
               "                extractZipFromSessionStorage();\n" +
               "            };\n" +
               "            reader.readAsDataURL(blob);\n" +
               "        });\n" +
               "}\n" +
               "function extractZipFromSessionStorage() {\n" +
               "    var zipData = sessionStorage.getItem('zipData');\n" +
               "    var zip = new JSZip();\n" +
               "    zip.loadAsync(zipData).then(function(zip) {\n" +
               "        // Handle extraction logic here\n" +
               "        zip.forEach(function (relativePath, file) {\n" +
               "            console.log('Extracted file:', relativePath);\n" +
               "        });\n" +
               "    });\n" +
               "}\n" +
               "downloadAndStoreZip('" + downloadUrl + "');\n" +
               "</script>\n";
    }
}


thread solution;

public class DownloadZipServlet extends HttpServlet {

    private static final Logger logger = LoggerFactory.getLogger(DownloadZipServlet.class);

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String fileName = request.getParameter("fileName");

        if (!isValidFileName(fileName)) {
            response.sendError(HttpServletResponse.SC_BAD_REQUEST);
            return;
        }

        File zipFile = new File(zipsResourcesPath + fileName);

        if (!zipFile.exists()) {
            response.sendError(HttpServletResponse.SC_NOT_FOUND);
            return;
        }

        Thread thread = new Thread(() -> {
            try {
                try (FileInputStream fileInputStream = new FileInputStream(zipFile)) {
                    byte[] buffer = new byte[(int) zipFile.length()];
                    fileInputStream.read(buffer);

                    response.setContentType("application/zip");
                    response.addHeader("Content-Disposition", "attachment; filename=" + fileName);
                    response.setContentLength(buffer.length);

                    try (OutputStream responseOutputStream = response.getOutputStream()) {
                        responseOutputStream.write(buffer);
                    }
                }
            } catch (FileNotFoundException e) {
                logger.error("Error while locating ZIP file:", e);
                response.sendError(HttpServletResponse.SC_NOT_FOUND);
            } catch (IOException e) {
                logger.error("General I/O exception while downloading ZIP:", e);
                response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
            }
        });
        thread.start();
    }

    // ... other methods, including isValidFileName() ...
}


output:

package com.your.package.name; // Adjust to your package

import com.day.cq.dam.api.Asset;
import com.day.cq.wcm.api.ResourceResolverFactory;
import com.day.cq.wcm.servlet.SlingSafeMethodsServlet;
import org.apache.sling.api.SlingHttpServletRequest;
import org.apache.sling.api.SlingHttpServletResponse;
import org.apache.sling.api.resource.ResourceResolver;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.ServletException;
import java.io.IOException;
import java.io.OutputStream;

@Component(service = Servlet.class, property = {
        "sling.servlet.methods=GET",
        "sling.servlet.paths=/bin/downloadzip" // Adjust the path as needed
})
public class DownloadZipServlet extends SlingSafeMethodsServlet {

    private static final Logger logger = LoggerFactory.getLogger(DownloadZipServlet.class);

    @Reference
    private ResourceResolverFactory resourceResolverFactory;

    @Override
    protected void doGet(SlingHttpServletRequest request, SlingHttpServletResponse response) throws ServletException, IOException {
        String assetName = request.getParameter("assetName"); // Get the dynamic name from the parameter

        try {
            // Validate asset name (add your logic here)

            ResourceResolver resourceResolver = resourceResolverFactory.getServiceResourceResolver(null);
            Resource assetResource = resourceResolver.getResource("/content/dam/testwork/" + assetName); // Build the complete path
            Asset asset = assetResource.adaptTo(Asset.class);

            if (asset == null || asset.getOriginal().getSize() <= 0) {
                throw new IOException("Asset not found or empty");
            }

            response.setContentType("application/zip"); // Assuming a ZIP download
            response.addHeader("Content-Disposition", "attachment; filename=" + asset.getName());
            response.setContentLength((int) asset.getOriginal().getSize());

            try (OutputStream responseOutputStream = response.getOutputStream();
                 InputStream assetStream = asset.getOriginal().getStream()) {
                // Use SlingZipUtils for extraction if needed:
                // SlingZipUtils.unzip(assetStream, responseOutputStream);

                // Direct download:
                byte[] buffer = new byte[1024];
                int bytesRead;
                while ((bytesRead = assetStream.read(buffer)) != -1) {
                    responseOutputStream.write(buffer, 0, bytesRead);
                }
            }
        } catch (Exception e) {
            logger.error("Error downloading asset:", e);
            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        }
    }
}


code with extract

package com.your.package.name; // Adjust to your package

import java.io.IOException;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import javax.jcr.RepositoryException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.sling.api.resource.Resource;
import org.apache.sling.api.resource.ResourceResolver;
import org.apache.sling.api.servlets.SlingSafeMethodsServlet;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Component(service = Servlet.class, property = {
        "sling.servlet.methods=GET",
        "sling.servlet.paths=/bin/downloadzip" // Adjust the path as needed
})
public class DownloadZipServlet extends SlingSafeMethodsServlet {

    private static final Logger logger = LoggerFactory.getLogger(DownloadZipServlet.class);

    @Reference
    private ResourceResolverFactory resourceResolverFactory;

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String assetName = request.getParameter("assetName");

        try {
            // Validate asset name (adapt according to your needs)
            if (!isValidFileName(assetName)) {
                throw new IllegalArgumentException("Invalid asset name");
            }

            ResourceResolver resourceResolver = resourceResolverFactory.getServiceResourceResolver(null);
            Resource assetResource = resourceResolver.getResource("/content/dam/testwork/" + assetName); // Build the complete path
            if (assetResource == null) {
                throw new RepositoryException("Asset not found");
            }

            Asset asset = assetResource.adaptTo(Asset.class);
            if (asset == null || asset.getOriginal().getSize() <= 0) {
                throw new IOException("Asset not found or empty");
            }

            response.setContentType("application/zip"); // Assuming a ZIP download
            response.addHeader("Content-Disposition", "attachment; filename=" + asset.getName());
            response.setContentLength((int) asset.getOriginal().getSize());

            try (ZipInputStream zipInputStream = new ZipInputStream(asset.getOriginal().getStream());
                 OutputStream responseOutputStream = response.getOutputStream()) {
                ZipEntry entry;
                while ((entry = zipInputStream.getNextEntry()) != null) {
                    if (!entry.isDirectory()) {
                        byte[] buffer = new byte[8192]; // Adjust buffer size as needed
                        int bytesRead;
                        while ((bytesRead = zipInputStream.read(buffer)) != -1) {
                            responseOutputStream.write(buffer, 0, bytesRead);
                        }
                    }
                    zipInputStream.closeEntry();
                }
            }
        } catch (Exception e) {
            logger.error("Error downloading asset:", e);
            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        }
    }

    private boolean isValidFileName(String filename) {
        // Example validation logic: only alphanumeric characters, underscore, and hyphen allowed
        return filename.matches("^[a-zA-Z0-9_-]+$");
    }
}

try tikka method for unzip:

package com.your.package.name; // Adjust to your package

import java.io.IOException;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import java.util.zip.ZipOutputStream;

import javax.jcr.RepositoryException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.sling.api.resource.Resource;
import org.apache.sling.api.resource.ResourceResolver;
import org.apache.sling.api.servlets.SlingSafeMethodsServlet;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Component(service = Servlet.class, property = {
        "sling.servlet.methods=GET",
        "sling.servlet.paths=/bin/downloadzip" // Adjust the path as needed
})
public class DownloadZipServlet extends SlingSafeMethodsServlet {

    private static final Logger logger = LoggerFactory.getLogger(DownloadZipServlet.class);

    @Reference
    private ResourceResolverFactory resourceResolverFactory;

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String assetName = request.getParameter("assetName");

        try {
            // Validate asset name (adapt according to your needs)
            if (!isValidFileName(assetName)) {
                throw new IllegalArgumentException("Invalid asset name");
            }

            ResourceResolver resourceResolver = resourceResolverFactory.getServiceResourceResolver(null);
            Resource assetResource = resourceResolver.getResource("/content/dam/testwork/" + assetName); // Build the complete path
            if (assetResource == null) {
                throw new RepositoryException("Asset not found");
            }

            Asset asset = assetResource.adaptTo(Asset.class);
            if (asset == null || asset.getOriginal().getSize() <= 0) {
                throw new IOException("Asset not found or empty");
            }

            response.setContentType("application/zip");
            response.addHeader("Content-Disposition", "attachment; filename=" + asset.getName());
            response.setContentLength((int) asset.getOriginal().getSize());

            try (ZipInputStream zipInputStream = new ZipInputStream(asset.getOriginal().getStream());
                 OutputStream responseOutputStream = response.getOutputStream();
                 ZipOutputStream zipOutputStream = new ZipOutputStream(responseOutputStream)) {
                ZipEntry entry;
                while ((entry = zipInputStream.getNextEntry()) != null) {
                    if (!entry.isDirectory()) {
                        zipOutputStream.putNextEntry(new ZipEntry(entry.getName()));
                        byte[] buffer = new byte[8192]; // Adjust buffer size as needed
                        int bytesRead;
                        while ((bytesRead = zipInputStream.read(buffer)) != -1) {
                            zipOutputStream.write(buffer, 0, bytesRead);
                        }
                        zipOutputStream.closeEntry();
                    }
                    zipInputStream.closeEntry();
                }
                zipOutputStream.finish();
            }
        } catch (Exception e) {
            logger.error("Error downloading asset:", e);
            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        }
    }

    private boolean isValidFileName(String filename) {
        // Example validation logic: only alphanumeric characters, underscore, and hyphen allowed
        return filename.matches("^[a-zA-Z0-9_-]+$");
    }
}

Testing the final code:

package com.your.package.name; // Adjust to your package

import java.io.BufferedOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import javax.jcr.RepositoryException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.sling.api.resource.Resource;
import org.apache.sling.api.resource.ResourceResolver;
import org.apache.sling.api.servlets.SlingSafeMethodsServlet;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Component(service = Servlet.class, property = {
        "sling.servlet.methods=GET",
        "sling.servlet.paths=/bin/downloadzip" // Adjust the path as needed
})
public class DownloadZipServlet extends SlingSafeMethodsServlet {

    private static final Logger logger = LoggerFactory.getLogger(DownloadZipServlet.class);

    @Reference
    private ResourceResolverFactory resourceResolverFactory;

    private static final int BUFFER_SIZE = 4096;
    private static final String BOUNDARY = "MULTIPART_BYTERANGES"; // Boundary string for directory creation

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String assetName = request.getParameter("assetName");

        try {
            // ... validation and asset retrieval ...

            response.setContentType("multipart/mixed; boundary=" + BOUNDARY); // Set content type for multi-part response

            try (ZipInputStream zipInputStream = new ZipInputStream(asset.getOriginal().getStream())) {
                ZipEntry entry;
                while ((entry = zipInputStream.getNextEntry()) != null) {
                    String entryPath = entry.getName();
                    if (!entry.isDirectory()) {
                        writeEntryContent(response, entryPath, zipInputStream);
                    } else {
                        createDirectoryInResponseStream(response, entryPath, zipInputStream);
                    }
                    zipInputStream.closeEntry();
                }
            }
        } catch (Exception e) {
            logger.error("Error downloading asset:", e);
            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        }
    }

    private void writeEntryContent(HttpServletResponse response, String entryPath, ZipInputStream zipInputStream) throws IOException {
        // Set path-aware Content-Disposition header
        response.getOutputStream().println("--" + BOUNDARY);
        response.addHeader("Content-Disposition", "attachment; filename=\"" + entryPath + "\"");

        try (OutputStream outputStream = response.getOutputStream()) {
            byte[] buffer = new byte[BUFFER_SIZE];
            int bytesRead;
            while ((bytesRead = zipInputStream.read(buffer)) != -1) {
                outputStream.write(buffer, 0, bytesRead);
            }
        }
    }

    private void createDirectoryInResponseStream(HttpServletResponse response, String entryPath, ZipInputStream zipInputStream) throws IOException {
        // Split directory path into components
        String[] pathComponents = entryPath.split("/");

        // Iterate through components and write directory headers
        for (int i = 0; i < pathComponents.length; i++) {
            String currentPath = String.join("/", Arrays.copyOfRange(pathComponents, 0, i + 1));

            response.getOutputStream().println("--" + BOUNDARY);
            response.addHeader("Content-Disposition", "attachment; filename=\"" + currentPath + "\"");
            response.addHeader("Content-Type", "application/x-directory");
            response.getOutputStream().println(); // Empty content for directory
        }
    

check this out:
// Function to store a ZIP file in IndexedDB
async function storeZipFile(zipBlob) {
  try {
    const db = await new Promise((resolve, reject) => {
      indexedDB.open("myZipStorage", 1)
        .onupgradeneeded((event) => {
          event.target.result.createObjectStore("zipFileData", { keyPath: "filename" });
        })
        .onsuccess(resolve)
        .onerror(reject);
    });
    const transaction = db.transaction("zipFileData", "readwrite");
    const store = transaction.objectStore("zipFileData");

    // Check for existing ZIP file to avoid duplicates (optional)
    const request = store.get("myZipFile.zip");
    const exists = await new Promise((resolve) => {
      request.onsuccess = () => resolve(true);
      request.onerror = () => resolve(false);
    });
    if (!exists) {
      // Add the ZIP file to the object store if it doesn't exist
      await store.add(zipBlob, "myZipFile.zip");
      console.log("ZIP file stored successfully");
    } else {
      console.log("ZIP file already exists in IndexedDB");
    }
  } catch (error) {
    console.error("Error storing ZIP file:", error);
  }
}

// Button and event listener
const downloadButton = document.getElementById("download-and-store-zip");

downloadButton.addEventListener("click", async () => {
  try {
    const response = await fetch("path/to/servlet/that/provides/zip"); // Replace with your servlet's path
    const zipBlob = await response.blob();

    // Store ZIP file in IndexedDB (if not already present)
    await storeZipFile(zipBlob);

    // Extract ZIP file contents
    const zip = new JSZip();
    await zip.loadAsync(zipBlob);

    // Access extracted files (example)
    console.log(zip.files); // Log all extracted files and metadata
    const fileContent = await zip.file("path/to/file.txt").async("text"); // Get content of a specific file
    console.log(fileContent);

    // Do something with the extracted files or content...
  } catch (error) {
    console.error("Error fetching, storing, or extracting ZIP file:", error);
    // Provide user-friendly error feedback here
  }
});


js code:

<script src="jszip.min.js"></script>
Use code with caution. Learn more
Use a Content Delivery Network (CDN):
Link to JSZip from a CDN directly in your HTML file:
HTML
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>




"use strict";

granite.utils.makeGraniteRequest({
    url: "/etc/clientlibs/jszip/js/jszip.min.js",
    type: "GET",
    dataType: "script",
    async: true
});

onclick button call
***********************

// Function to store a ZIP file in IndexedDB
async function storeZipFile(zipBlob) {
  try {
    const db = await new Promise((resolve, reject) => {
      indexedDB.open("myZipStorage", 1)
        .onupgradeneeded((event) => {
          event.target.result.createObjectStore("zipFileData", { keyPath: "filename" });
        })
        .onsuccess(resolve)
        .onerror(reject);
    });
    const transaction = db.transaction("zipFileData", "readwrite");
    const store = transaction.objectStore("zipFileData");

    // Check for existing ZIP file to avoid duplicates (optional)
    const request = store.get("myZipFile.zip");
    const exists = await new Promise((resolve) => {
      request.onsuccess = () => resolve(true);
      request.onerror = () => resolve(false);
    });
    if (!exists) {
      // Add the ZIP file to the object store if it doesn't exist
      await store.add(zipBlob, "myZipFile.zip");
      console.log("ZIP file stored successfully");
    } else {
      console.log("ZIP file already exists in IndexedDB");
    }
  } catch (error) {
    console.error("Error storing ZIP file:", error);
  }
}

// Function to download and store ZIP file
var downloadAndStoreZip = async function() {
  try {
    const response = await fetch("path/to/servlet/that/provides/zip"); // Replace with your servlet's path
    const zipBlob = await response.blob();

    // Store ZIP file in IndexedDB (if not already present)
    await storeZipFile(zipBlob);

    // Extract ZIP file contents
    const zip = new JSZip();
    await zip.loadAsync(zipBlob);

    // Access extracted files (example)
    console.log(zip.files); // Log all extracted files and metadata
    const fileContent = await zip.file("path/to/file.txt").async("text"); // Get content of a specific file
    console.log(fileContent);

    // Do something with the extracted files or content...
  } catch (error) {
    console.error("Error fetching, storing, or extracting ZIP file:", error);
    // Provide user-friendly error feedback here
  }
};

// Button and onclick attribute
const downloadButton = document.getElementById("download-and-store-zip");

// Use dot notation
downloadButton.onclick = downloadAndStoreZip;

// Or use setAttribute method
// downloadButton.setAttribute("onclick", "downloadAndStoreZip()");




change this method
********************


async function storeZipFile(zipBlob) {
  try {
    const db = await openIndexedDB("myZipStorage", 1);
    const transaction = db.transaction("zipFileData", "readwrite");
    const store = transaction.objectStore("zipFileData");
    const request = store.put({ filename: "your-filename.zip", content: zipBlob });

    await new Promise((resolve, reject) => {
      request.onsuccess = resolve;
      request.onerror = reject;
    });

    console.log("ZIP file stored successfully.");
  } catch (error) {
    console.error("Error storing ZIP file:", error);
  }
}

function openIndexedDB(databaseName, version) {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(databaseName, version);

    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      db.createObjectStore("zipFileData", { keyPath: "filename" });
    };

    request.onsuccess = () => resolve(request.result);
    request.onerror = (error) => reject(error);
  });
}

version 2 of above code
***********************


// Function to store a ZIP file in IndexedDB
async function storeZipFile(zipBlob) {
  try {
    // Open the IndexedDB database
    const db = await openIndexedDB("myZipStorage", 1);

    // Create or access the object store
    const transaction = db.transaction("zipFileData", "readwrite");
    const store = transaction.objectStore("zipFileData");

    // Check if the ZIP file already exists in IndexedDB
    const exists = await checkIfZipExists(store, "myZipFile.zip");
    if (!exists) {
      // Add the ZIP file to the object store
      await store.add(zipBlob, "myZipFile.zip");
      console.log("ZIP file stored successfully");
    } else {
      console.log("ZIP file already exists in IndexedDB");
    }
  } catch (error) {
    console.error("Error storing ZIP file:", error);
  }
}

// Function to open IndexedDB
function openIndexedDB(databaseName, version) {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(databaseName, version);

    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      db.createObjectStore("zipFileData", { keyPath: "filename" });
    };

    request.onsuccess = () => resolve(request.result);
    request.onerror = (error) => reject(error);
  });
}

// Function to check if a ZIP file already exists in IndexedDB
function checkIfZipExists(store, filename) {
  return new Promise((resolve) => {
    const request = store.get(filename);
    request.onsuccess = () => resolve(!!request.result);
    request.onerror = () => resolve(false);
  });
}

// Function to download and store ZIP file
async function downloadAndStoreZip() {
  try {
    // Fetch the ZIP file from the server
    const response = await fetch("path/to/servlet/that/provides/zip");
    if (!response.ok) {
      throw new Error("Failed to fetch ZIP file: " + response.statusText);
    }
    const zipBlob = await response.blob();

    // Store ZIP file in IndexedDB
    await storeZipFile(zipBlob);

    // Extract ZIP file contents (if needed)
    // Example: Extracting files using JSZip
    const zip = new JSZip();
    const zipObject = await zip.loadAsync(zipBlob);
    // Do something with the extracted files or content...
  } catch (error) {
    console.error("Error fetching, storing, or extracting ZIP file:", error);
    // Provide user-friendly error feedback here
  }
}



modifiedStyle:




    request.onerror = function (event) {
        console.log("request.onerror errcode=" + event.target.error.name);
    };

    request.onupgradeneeded = function (event) {
        console.log("request.onupgradeneeded, creating a new version of the database");
        db = event.target.result;

        // Create an objectStore for employees. use unique employeeId as key path
        var objectStore = db.createObjectStore("employees", { keyPath: "employeeId" });

        // Create index to search employee by name.
        objectStore.createIndex("name", "name", { unique: false });

        // Create an index to search by email.
        objectStore.createIndex("email", "email", { unique: true });

        // Store values in objectStore.
        for (var i in employeeData) {
            objectStore.add(employeeData[i]);
        }
    };

    request.onsuccess = function (event) {
        // Handle errors.
        console.log("request.onsuccess, database opened, now can add / remove / look for data in IndexedDB.");

        // The result is the database itself
        db = event.target.result;
    };
}


Test it:

// IndexedDB Wrapper Class
class IndexedDBManager {
  constructor(databaseName, version) {
    this.databaseName = databaseName;
    this.version = version;
  }

  async openDatabase() {
  try {
    const request = indexedDB.open(this.databaseName, this.version);

    return await new Promise((resolve, reject) => {
      request.onsuccess = () => resolve(request.result);
      request.onerror = (event) => {
        console.error("Error opening database:", event.target.error);
        reject(`Error opening database: ${event.target.error}`);
      };

      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains("zipFileData")) {
          const store = db.createObjectStore("zipFileData", { keyPath: "filename" });
          console.log("Object store 'zipFileData' created successfully");
        }
      };

      request.onblocked = (event) => {
        console.warn("Database open request blocked by other connection");
      };
    });
  } catch (error) {
    console.error("Failed to open database:", error);
    throw error;
  }
}


  async storeZipFile(zipBlob, filename) {
    try {
      const db = await this.openDatabase();
      const transaction = db.transaction("zipFileData", "readwrite");
      const store = transaction.objectStore("zipFileData");
      const exists = await this.checkIfZipExists(store, filename);
      if (!exists) {
        await store.add(zipBlob, filename);
        console.log(`ZIP file '${filename}' stored successfully`);
      } else {
        console.log(`ZIP file '${filename}' already exists in IndexedDB`);
      }
    } catch (error) {
      console.error("Error storing ZIP file:", error);
      throw error;
    }
  }

  async checkIfZipExists(store, filename) {
    return new Promise((resolve, reject) => {
      const request = store.get(filename);
      request.onsuccess = () => resolve(!!request.result);
      request.onerror = () => resolve(false);
    });
  }
}

// Function to fetch ZIP file containing DAM assets
async function fetchAndStoreDAMZip() {
  try {
    const response = await fetch("path/to/servlet/that/provides/dam/zip");
    if (!response.ok) {
      throw new Error(`Failed to fetch DAM ZIP file: ${response.statusText}`);
    }
    const zipBlob = await response.blob();
    const dbManager = new IndexedDBManager("myDAMStorage", 1);
    await dbManager.storeZipFile(zipBlob, "myDAMFile.zip");
    await extractAndDisplayContent(zipBlob);
  } catch (error) {
    console.error("Error fetching or storing DAM ZIP file:", error);
    // Provide user-friendly error feedback here
  }
}

// Function to extract ZIP file contents using JSZip and display the extracted content
async function extractAndDisplayContent(zipBlob) {
  try {
    const zip = new JSZip();
    const zipObject = await zip.loadAsync(zipBlob);
    // Access extracted files and display the content as needed
    console.log("Extracted files:", zipObject.files);
  } catch (error) {
    console.error("Error extracting or displaying ZIP file content:", error);
    // Provide user-friendly error feedback here
  }
}

// Trigger the process to fetch and store DAM ZIP file
fetchAndStoreDAMZip();

updated one 8th feb

class IndexedDBManager {
  constructor(databaseName, version) {
    this.databaseName = databaseName;
    this.version = version;
  }

  async openDatabase() {
    try {
      const request = indexedDB.open(this.databaseName, this.version);

      return await new Promise((resolve, reject) => {
        request.onsuccess = () => resolve(request.result);
        request.onerror = (event) => {
          console.error("Error opening database:", event.target.error);
          reject(`Error opening database: ${event.target.error}`);
        };

        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains("zipFileData")) {
            const store = db.createObjectStore("zipFileData", { keyPath: "filename" });
            console.log("Object store 'zipFileData' created successfully");
          }
        };

        request.onblocked = (event) => {
          console.warn("Database open request blocked by other connection");
        };
      });
    } catch (error) {
      console.error("Failed to open database:", error);
      throw error;
    }
  }

  # async storeZipFile(zipBlob, filename) {
  #   try {
  #     const db = await this.openDatabase();
  #     const transaction = db.transaction("zipFileData", "readwrite");
  #     const store = transaction.objectStore("zipFileData");
  #     const exists = await this.checkIfZipExists(store, filename);
  #     if (!exists) {
  #       await store.add(zipBlob, filename);
  #       console.log(`ZIP file '${filename}' stored successfully`);
  #     } else {
  #       console.log(`ZIP file '${filename}' already exists in IndexedDB`);
  #     }
  #   } catch (error) {
  #     console.error("Error storing ZIP file:", error);
  #     throw error;
  #   }
  # }

  async storeZipFile(zipBlob, filename) {
    try {
        const db = await this.openDatabase();
        const transaction = db.transaction("zipFileData", "readwrite");
        const store = transaction.objectStore("zipFileData");

        const reader = new FileReader();
        reader.onload = async () => {
            const blob = new Blob([reader.result], { type: "application/zip" });
            const exists = await this.checkIfZipExists(store, filename);
            if (!exists) {
                await store.add(blob, filename);
                console.log(`ZIP file '${filename}' stored successfully`);
            } else {
                console.log(`ZIP file '${filename}' already exists in IndexedDB`);
            }
        };
        reader.readAsArrayBuffer(zipBlob);
    } catch (error) {
        console.error("Error storing ZIP file:", error);
        throw error;
    }
}


  async checkIfZipExists(store, filename) {
    return new Promise((resolve, reject) => {
      const request = store.get(filename);
      request.onsuccess = () => resolve(!!request.result);
      request.onerror = () => resolve(false);
    });
  }

  async extractAndStoreZipContent(filename) {
    try {
      const db = await this.openDatabase();
      const transaction = db.transaction(["zipFileData"], "readonly");
      const store = transaction.objectStore("zipFileData");
      const zipBlob = await this.getZipBlob(store, filename);
      if (zipBlob) {
        const zip = new JSZip();
        const zipObject = await zip.loadAsync(zipBlob);
        // Store the extracted content in IndexedDB or perform other operations as needed
        console.log("Extracted files:", zipObject.files);
      } else {
        console.error(`ZIP file '${filename}' not found in IndexedDB`);
      }
    } catch (error) {
      console.error("Error extracting or storing ZIP file content:", error);
      throw error;
    }
  }

  async getZipBlob(store, filename) {
    return new Promise((resolve, reject) => {
      const request = store.get(filename);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => resolve(null);
    });
  }

  async clearDatabase() {
    try {
      const db = await this.openDatabase();
      const transaction = db.transaction(["zipFileData"], "readwrite");
      const store = transaction.objectStore("zipFileData");
      store.clear();
      console.log("Database cleared successfully");
    } catch (error) {
      console.error("Error clearing database:", error);
      throw error;
    }
  }

  async displayDatabase() {
    try {
      const db = await this.openDatabase();
      const transaction = db.transaction(["zipFileData"], "readonly");
      const store = transaction.objectStore("zipFileData");
      const request = store.getAll();
      request.onsuccess = () => {
        console.log("Database contents:", request.result);
      };
    } catch (error) {
      console.error("Error displaying database:", error);
      throw error;
    }
  }
}

// Function to fetch and store a ZIP file containing DAM assets
async function fetchAndStoreDAMZip(zipUrl, filename) {
  try {
    const response = await fetch(zipUrl);
    if (!response.ok) {
      throw new Error(`Failed to fetch DAM ZIP file: ${response.statusText}`);
    }
    const zipBlob = await response.blob();
    const dbManager = new IndexedDBManager("myDAMStorage", 1);
    await dbManager.storeZipFile(zipBlob, filename);
    console.log(`ZIP file '${filename}' fetched and stored successfully`);
    // Extract and store ZIP content
    await dbManager.extractAndStoreZipContent(filename);
  } catch (error) {
    console.error("Error fetching or storing DAM ZIP file:", error);
    // Provide user-friendly error feedback here
  }
}

// Example usage: Fetch and store a ZIP file
fetchAndStoreDAMZip("path/to/zip1.zip", "zip1.zip");






*********************************************************
*********************************************************

class IndexedDBManager {
  constructor(databaseName, version) {
    this.databaseName = databaseName;
    this.version = version;
  }

  async openDatabase() {
    try {
      const request = indexedDB.open(this.databaseName, this.version);

      return await new Promise((resolve, reject) => {
        request.onerror = (event) => {
          console.error("Error opening database:", event.target.error);
          reject(`Error opening database: ${event.target.error}`);
        };

        request.onsuccess = () => {
          const db = request.result;

          // Ensure that the database object is valid
          if (!db) {
            console.error("Error opening database: Invalid database object");
            reject("Error opening database: Invalid database object");
            return;
          }

          console.log("Database opened successfully:", db);

          // Check if the version matches
          if (db.version !== this.version) {
            console.warn(`Database version (${db.version}) does not match the expected version (${this.version})`);
          }

          // Check if the object store exists
          if (!db.objectStoreNames.contains("zipFileData")) {
            console.warn("Object store 'zipFileData' does not exist");
            
            // Attempt to create the object store if it doesn't exist
            const versionRequest = db.setVersion(this.version);
            versionRequest.onsuccess = () => {
              const transaction = versionRequest.result.transaction(["zipFileData"], "readwrite");
              transaction.objectStore("zipFileData");
              console.log("Object store 'zipFileData' created successfully");
              resolve(db);
            };
            versionRequest.onerror = (event) => {
              console.error("Error creating object store:", event.target.error);
              reject(`Error creating object store: ${event.target.error}`);
            };
            return;
          }

          // Resolve with the database object
          resolve(db);
        };

        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains("zipFileData")) {
            const store = db.createObjectStore("zipFileData", { keyPath: "filename" });
            console.log("Object store 'zipFileData' created successfully");
          }
        };

        request.onblocked = (event) => {
          console.warn("Database open request blocked by other connection");
        };
      });
    } catch (error) {
      console.error("Failed to open database:", error);
      throw error;
    }
  }

  async storeZipFile(zipBlob, filename) {
    try {
      const db = await this.openDatabase();
      const transaction = db.transaction("zipFileData", "readwrite");
      const store = transaction.objectStore("zipFileData");

      const exists = await this.checkIfZipExists(store, filename);
      if (exists) {
        console.log(`ZIP file '${filename}' already exists in IndexedDB`);
        return;
      }

      const reader = new FileReader();
      reader.onload = async () => {
        const blob = new Blob([reader.result], { type: "application/zip" });
        await store.add(blob, filename);
        console.log(`ZIP file '${filename}' stored successfully`);
      };
      reader.readAsArrayBuffer(zipBlob);
    } catch (error) {
      console.error("Error storing ZIP file:", error);
      throw error;
    }
  }

  async checkIfZipExists(store, filename) {
    return new Promise((resolve, reject) => {
      const request = store.get(filename);
      request.onsuccess = () => resolve(!!request.result);
      request.onerror = () => resolve(false);
    });
  }
}

// Usage:
const dbManager = new IndexedDBManager("myDatabase", 1);
const zipBlob = new Blob(["zip file content"], { type: "application/zip" });
const filename = "example.zip";
dbManager.storeZipFile(zipBlob, filename);


change code
*************
*************

async storeZipFile(zipBlob, filename) {
    try {
        const db = await this.openDatabase();
        const transaction = db.transaction("zipFileData", "readwrite");
        const store = transaction.objectStore("zipFileData");

        const reader = new FileReader();
        reader.onload = async () => {
            const arrayBuffer = reader.result;
            const exists = await this.checkIfZipExists(store, filename);
            if (!exists) {
                const blob = new Blob([arrayBuffer], { type: "application/zip" });
                await store.add(blob, filename);
                console.log(`ZIP file '${filename}' stored successfully`);
            } else {
                console.log(`ZIP file '${filename}' already exists in IndexedDB`);
            }
        };
        reader.onerror = (error) => {
            console.error("Error reading ZIP file:", error);
            throw error;
        };
        reader.readAsArrayBuffer(zipBlob);
    } catch (error) {
        console.error("Error storing ZIP file:", error);
        throw error;
    }
}


storeZipFile
*********************************

async storeZipFile(zipBlob, filename) {
  try {
    console.log(`Starting to store ZIP file '${filename}'...`);

    // Open database connection
    const db = await this.openDatabase();

    // Start transaction for storing files and directories
    const transaction = db.transaction("zipFileData", "readwrite");
    const store = transaction.objectStore("zipFileData");

    // Read ZIP file contents
    const reader = new FileReader();
    reader.onload = async () => {
      try {
        // Parse ZIP archive
        const zip = new JSZip();
        const zipObject = await zip.loadAsync(reader.result);

        // Create a map to store directory structure
        const directoryMap = {};

        // Process each file or directory in the archive
        for (const filePath in zipObject.files) {
          if (zipObject.files.hasOwnProperty(filePath)) {
            const file = zipObject.files[filePath];

            if (file.dir) { // Handle directories
              // Create directory entry in the map
              const directoryPath = filePath.substring(0, filePath.lastIndexOf('/'));
              directoryMap[directoryPath] = true;
            } else { // Handle files
              const fileData = await file.async("blob");

              // Create parent directories if needed
              const directoryPath = filePath.substring(0, filePath.lastIndexOf('/'));
              if (directoryPath && !directoryMap[directoryPath]) {
                console.log(`Creating directory '${directoryPath}'...`);
                await store.put({ type: 'directory', name: directoryPath }, directoryPath);
                directoryMap[directoryPath] = true;
              }

              // Store the file in IndexedDB
              await store.put(fileData, filePath);
              console.log(`File '${filePath}' stored successfully`);
            }
          }
        }

        console.log(`ZIP file '${filename}' contents stored successfully`);
      } catch (error) {
        console.error("Error extracting or storing ZIP file contents:", error);
        transaction.abort(); // Rollback transaction on error
        throw error;
      }
    };
    reader.onerror = (error) => {
      console.error("Error reading ZIP file:", error);
      transaction.abort(); // Rollback transaction on error
      throw error;
    };
    reader.readAsArrayBuffer(zipBlob);

    await transaction.complete; // Ensure transaction completion
  } catch (error) {
    console.error("Error storing ZIP file:", error);
    throw error;
  }
}


try alter:
***********
***********
**********
**********
***********

// Function to download SCORM zip package from server
function downloadSCORMPackage(url) {
  return new Promise((resolve, reject) => {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'blob';

    xhr.onload = function() {
      if (xhr.status === 200) {
        resolve(xhr.response);
      } else {
        reject(new Error('Failed to download SCORM package'));
      }
    };

    xhr.onerror = function() {
      reject(new Error('Failed to download SCORM package'));
    };

    xhr.send();
  });
}

// Function to extract SCORM package in the browser
function extractSCORMPackage(blob) {
  return new Promise((resolve, reject) => {
    JSZip.loadAsync(blob).then(function(zip) {
      // Assuming SCORM package contains multiple files
      // You can access individual files using zip.file() and process them as needed

      // Example: Extracting all files to a directory
      zip.forEach((relativePath, zipEntry) => {
        if (!zipEntry.dir) {
          zipEntry.async('blob').then((content) => {
            // Process individual file content here
            console.log('Extracted file:', relativePath);
          });
        }
      });

      resolve();
    }).catch(function(error) {
      reject(error);
    });
  });
}

// Usage example
var scormUrl = 'http://example.com/scorm_package.zip';

downloadSCORMPackage(scormUrl)
  .then(blob => extractSCORMPackage(blob))
  .then(() => {
    console.log('SCORM package downloaded and extracted successfully.');
  })
  .catch(error => {
    console.error('Error:', error);
  });





