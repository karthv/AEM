
Steps to Configure Custom Logs in AEM:
1. Use SLF4J for Logging in Code
AEM uses SLF4J for logging. To create custom logs in your Java code, you can define a logger as follows:

java
Copy code
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class MyComponent {
    private static final Logger LOG = LoggerFactory.getLogger(MyComponent.class);

    public void myMethod() {
        LOG.info("This is an info message");
        LOG.error("This is an error message");
        LOG.debug("This is a debug message");
    }
}
The LoggerFactory.getLogger(MyComponent.class) method ensures that logs from this class are captured with the appropriate log category.

2. Create a Custom Log File via OSGi Configuration
To capture the logs into a custom file, you need to configure a custom log file for the specific logger (category) using AEMâ€™s OSGi configuration manager. Here's how you can do this:

Access OSGi Web Console:

Navigate to http://<AEM-Host>:<Port>/system/console/configMgr
Log in with administrative credentials.
Create a Logger Configuration:

Look for the configuration named Apache Sling Logging Logger Configuration in the OSGi console.
Click + to create a new configuration.
Configure the Logger: In the configuration, you will need to set up the following properties:

Log Level: Choose the log level (INFO, DEBUG, ERROR, etc.).
Log File: Specify the path where the log file will be stored. For example: logs/my-custom-log.log.
Log Category: This should match the fully qualified class name (FQCN) of your Java class, or a package if you want to log multiple classes. For example, if you want to log all classes under com.mycompany.myproject, use that as the category.
Log Format: You can define a custom format for your logs (optional).
Example configuration:

Log Level: INFO
Log File: logs/mycomponent.log
Log Category: com.mycompany.myproject.components.MyComponent
Click Save.

Configure a Log File Appender: You also need to configure a log file appender:

Look for Apache Sling Logging Writer Configuration in the OSGi console.
Click + to create a new writer configuration.
In the configuration:

Log File: Specify the file path (same as above, e.g., logs/mycomponent.log).
Number of Rotated Files: Specify the number of log files to keep.
Maximum File Size: Specify the size before a new log file is created.
3. Customizing the Log Format (Optional)
You can customize the log format in the Apache Sling Logging Writer Configuration by setting the Log Format property. The format uses Logback's pattern syntax.

Example pattern:

perl
Copy code
[%d{ISO8601}] [%thread] %-5level %logger{36} - %msg%n
This will print log messages in the format:

csharp
Copy code
[2024-10-15 14:28:33] [main] INFO  com.mycompany.myproject.components.MyComponent - This is an info message
4. Testing the Custom Log
Once the configuration is set, you can trigger the functionality in your code and check the log file (e.g., logs/mycomponent.log) to see the custom logs being captured.

You can view the logs using the tail command in your terminal:

bash
Copy code
tail -f <AEM_installation_directory>/crx-quickstart/logs/mycomponent.log
Or check them directly in the AEM environment by navigating to the logs directory:

bash
Copy code
/crx-quickstart/logs/


import org.apache.commons.lang3.StringUtils;
import org.apache.sling.api.SlingHttpServletRequest;
import org.apache.sling.api.resource.Resource;
import org.apache.sling.api.resource.ResourceResolver;
import org.apache.sling.api.resource.ValueMap;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.xhtmlrenderer.pdf.ITextRenderer;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpServletResponseWrapper;
import java.io.*;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.Objects;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

public class ServletUtil {

    private ServletUtil() {
        throw new IllegalStateException("Utility class");
    }

    private static final Logger LOG = LoggerFactory.getLogger(ServletUtil.class);
    private static final String PROP_CONF_DOMAIN = "domain";
    private static final String CONTENT_NODE = "/content";

    // Store StandardCharsets.UTF_8.name() in a constant for performance
    private static final String UTF_8_STRING = StandardCharsets.UTF_8.name();

    // Method 1: Get HTML Content
    public static String getHtmlContent(HttpServletRequest request, HttpServletResponse response, String url) {
        try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
             PrintWriter writer = new PrintWriter(new OutputStreamWriter(outputStream, StandardCharsets.UTF_8))) {

            RequestDispatcher dispatcher = request.getRequestDispatcher(url);
            if (dispatcher == null) {
                LOG.error("Dispatcher for URL '{}' is null", url);
                return null;
            }

            HttpServletResponse capturingResponse = new HttpServletResponseWrapper(response) {
                @Override
                public PrintWriter getWriter() {
                    return writer;
                }
            };

            dispatcher.include(request, capturingResponse);
            writer.flush();

            return outputStream.toString(UTF_8_STRING); // Use the constant
        } catch (IOException | ServletException e) {
            LOG.error("Error while generating HTML content from URL '{}': {}", url, e.getMessage(), e);
            return null;
        }
    }

    // Method 2: Output PDF
    public static InputStream outputPDF(String htmlString, SlingHttpServletRequest request,
                                        ResourceResolver resourceResolver, File outputFile, String[] pageAttributes) throws IOException {
        try (OutputStream fileOutputStream = new FileOutputStream(outputFile)) {
            ITextRenderer renderer = new ITextRenderer();
            Document document = addDocumentStyle(htmlString, pageAttributes);
            addAnchorLinkStyle(document, request);
            cleanDocument(document);

            renderer.setDocument(new org.jsoup.helper.W3CDom().fromJsoup(document), null);
            renderer.layout();
            renderer.createPDF(fileOutputStream);

            return new FileInputStream(outputFile);
        } catch (Exception e) {
            LOG.error("Error generating PDF content: {}", e.getMessage(), e);
            return null;
        }
    }

    // Method 3: Convert HTML to File
    public static InputStream convertHtmlToFile(String htmlOfPage, SlingHttpServletRequest request,
                                                ResourceResolver resolver, String[] pageAttributes) {
        try {
            Document document = addDocumentStyle(htmlOfPage, pageAttributes);
            cleanDocument(document);
            addAnchorLinkStyle(document, request);

            byte[] htmlBytes = document.html().getBytes(UTF_8_STRING); // Use the constant
            return new ByteArrayInputStream(htmlBytes);
        } catch (Exception e) {
            LOG.error("Error converting HTML to file: {}", e.getMessage(), e);
            return null;
        }
    }

    // Method 4: Add Document Style
    private static Document addDocumentStyle(String htmlOfPage, String[] pageAttributes) {
        Document document = Jsoup.parse(htmlOfPage, UTF_8_STRING); // Use the constant
        for (String tag : pageAttributes) {
            document.select(tag).forEach(Element::remove);
        }
        document.select("body").attr("style", "font-family: Arial, sans-serif; font-size: 14px;");
        return document;
    }

    // Method 5: Clean Document
    private static void cleanDocument(Document document) {
        // Remove unwanted classes or components
        document.select("div.unwanted-class, video.movie__loop").forEach(Element::remove);

        // Handle video component references
        Elements videoLinks = document.select("[data-video-narrow]");
        for (Element videoElement : videoLinks) {
            try {
                String imgPath = URLDecoder.decode(videoElement.attr("data-video-narrow"), UTF_8_STRING);
                String lastPath = StringUtils.substringBeforeLast(imgPath, "/");
                Element imgElement = videoElement.appendElement("img");
                imgElement.attr("src", lastPath + "/resolved-image.jpg");
                imgElement.attr("style", "width:100%; height:auto;");
            } catch (UnsupportedEncodingException e) {
                LOG.error("Error decoding video path: {}", e.getMessage(), e);
            }
        }

        // Handle movie component references
        Elements movieElements = document.select("div.movie-component");
        for (Element movieElement : movieElements) {
            Element videoTag = movieElement.selectFirst("video");
            if (videoTag != null) {
                Element sourceTag = videoTag.selectFirst("source");
                if (sourceTag != null) {
                    try {
                        String src = URLDecoder.decode(sourceTag.attr("src"), UTF_8_STRING);
                        sourceTag.attr("src", "/media/" + StringUtils.substringAfterLast(src, "/"));
                    } catch (UnsupportedEncodingException e) {
                        LOG.error("Error decoding movie path: {}", e.getMessage(), e);
                    }
                }
            }
        }

        // Handle accordion components
        Elements accordionElements = document.select("div.accordion");
        for (Element accordion : accordionElements) {
            Elements items = accordion.select("div.item");
            for (Element item : items) {
                Elements images = item.select("img");
                for (Element img : images) {
                    try {
                        String imgSrc = URLDecoder.decode(img.attr("src"), UTF_8_STRING);
                        img.attr("src", "/accordion/media/" + StringUtils.substringAfterLast(imgSrc, "/"));
                        img.attr("style", "width:auto; height:auto;");
                    } catch (UnsupportedEncodingException e) {
                        LOG.error("Error decoding accordion image path: {}", e.getMessage(), e);
                    }
                }
            }
        }

        // Handle image styling
        Elements images = document.select("img");
        for (Element img : images) {
            try {
                String imgSrc = URLDecoder.decode(img.attr("src"), UTF_8_STRING);
                if (imgSrc.startsWith("/content")) {
                    img.attr("src", "/media/" + StringUtils.substringAfterLast(imgSrc, "/"));
                    img.attr("style", "max-width:100%; height:auto;");
                }
            } catch (UnsupportedEncodingException e) {
                LOG.error("Error decoding image path: {}", e.getMessage(), e);
            }
        }
    }

    // Method 6: Add Anchor Link Style
    private static void addAnchorLinkStyle(Document document, SlingHttpServletRequest request) {
        String domainName = getDomain(request);
        document.select("a[href]").forEach(link -> {
            try {
                String href = URLDecoder.decode(link.attr("href"), UTF_8_STRING); // Use the constant
                if (domainName != null && href.startsWith(CONTENT_NODE)) {
                    link.attr("href", domainName + href);
                }
            } catch (UnsupportedEncodingException e) {
                LOG.error("Error decoding URL '{}': {}", link.attr("href"), e.getMessage(), e);
            }
        });
    }

    // Method 7: Get Domain
    public static String getDomain(SlingHttpServletRequest request) {
        Resource resource = request.getResource();
        ValueMap properties = resource.adaptTo(ValueMap.class);
        String domain = properties.get(PROP_CONF_DOMAIN, "");
        if (StringUtils.isBlank(domain)) {
            String pageURL = request.getRequestURL().toString();
            domain = StringUtils.substringBefore(pageURL, CONTENT_NODE);
        }
        return domain;
    }

    // Method 8: Copy Media Stream
    public static void copyMediaStream(ZipOutputStream zipOutputStream, String childNodeUrl, List<String> assets,
                                       Asset asset) throws IOException {
        try (InputStream mediaInputStream = asset.getOriginal().getStream()) {
            zipOutputStream.putNextEntry(new ZipEntry(childNodeUrl + asset.getName()));
            byte[] buffer = new byte[1024];
            int length;
            while ((length = mediaInputStream.read(buffer)) > 0) {
                zipOutputStream.write(buffer, 0, length);
            }
            assets.add(asset.getName());
        } catch (IOException e) {
            LOG.error("Error creating folders inside zip '{}': {}", e.getMessage(), e);
        } finally {
            zipOutputStream.closeEntry();
        }
    }
}

import org.apache.commons.lang3.StringUtils;
import org.apache.sling.api.SlingHttpServletRequest;
import org.apache.sling.api.resource.Resource;
import org.apache.sling.api.resource.ResourceResolver;
import org.apache.sling.api.resource.ValueMap;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.xhtmlrenderer.pdf.ITextRenderer;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpServletResponseWrapper;
import java.io.*;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

public class ServletUtil {

    private ServletUtil() {
        throw new IllegalStateException("Utility class");
    }

    private static final Logger LOG = LoggerFactory.getLogger(ServletUtil.class);
    private static final String PROP_CONF_DOMAIN = "domain";
    private static final String CONTENT_NODE = "/content";

    // Store StandardCharsets.UTF_8.name() in a constant for performance
    private static final String UTF_8_STRING = StandardCharsets.UTF_8.name();

    // Method 1: Get HTML Content
    public static String getHtmlContent(HttpServletRequest request, HttpServletResponse response, String url) {
        try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
             PrintWriter writer = new PrintWriter(new OutputStreamWriter(outputStream, StandardCharsets.UTF_8))) {

            RequestDispatcher dispatcher = request.getRequestDispatcher(url);
            if (dispatcher == null) {
                LOG.error("Dispatcher for URL '{}' is null", url);
                return null;
            }

            HttpServletResponse capturingResponse = new HttpServletResponseWrapper(response) {
                @Override
                public PrintWriter getWriter() {
                    return writer;
                }
            };

            dispatcher.include(request, capturingResponse);
            writer.flush();

            return outputStream.toString(UTF_8_STRING);
        } catch (IOException | ServletException e) {
            LOG.error("Error while generating HTML content from URL '{}': {}", url, e.getMessage(), e);
            return null;
        }
    }

    // Method 2: Output PDF
    public static InputStream outputPDF(String htmlString, SlingHttpServletRequest request,
                                        ResourceResolver resourceResolver, File outputFile, String[] pageAttributes) throws IOException {
        try (OutputStream fileOutputStream = new FileOutputStream(outputFile)) {
            ITextRenderer renderer = new ITextRenderer();

            // Parse and process the HTML document
            Document document = addDocumentStyle(htmlString, pageAttributes);
            addAnchorLinkStyle(document, request);
            addImageStyle(resourceResolver, document);

            // Convert Jsoup Document to W3C DOM for PDF rendering
            org.w3c.dom.Document pdfDocument = new org.jsoup.helper.W3CDom().fromJsoup(document);

            renderer.setDocument(pdfDocument, null);
            renderer.layout();

            // Generate the PDF
            renderer.createPDF(fileOutputStream);

            // Return PDF as InputStream
            return new FileInputStream(outputFile);
        } catch (Exception e) {
            LOG.error("Error generating PDF content: {}", e.getMessage(), e);
            return null;
        }
    }

    // Method 3: Convert HTML to File
    public static InputStream convertHtmlToFile(String htmlOfPage, SlingHttpServletRequest request,
                                                ResourceResolver resolver, String[] pageAttributes) {
        try {
            Document document = addDocumentStyle(htmlOfPage, pageAttributes);
            updateVideoComponentReferences(resolver, document);
            updateMovieComponentReferences(document);

            byte[] htmlBytes = document.html().getBytes(UTF_8_STRING);
            return new ByteArrayInputStream(htmlBytes);
        } catch (Exception e) {
            LOG.error("Error converting HTML to file: {}", e.getMessage(), e);
            return null;
        }
    }

    // Method 4: Add Document Style
    private static Document addDocumentStyle(String htmlOfPage, String[] pageAttributes) {
        Document document = Jsoup.parse(htmlOfPage, UTF_8_STRING);
        for (String tag : pageAttributes) {
            document.select(tag).forEach(Element::remove);
        }
        document.select("body").attr("style", "font-family: Arial, sans-serif; font-size: 14px;");
        return document;
    }

    // Method 5: Update Video Component References
    private static void updateVideoComponentReferences(ResourceResolver resolver, Document document) {
        Elements videoElements = document.select("[data-video-narrow]");
        for (Element videoElement : videoElements) {
            try {
                String videoPath = URLDecoder.decode(videoElement.attr("data-video-narrow"), UTF_8_STRING);
                String basePath = StringUtils.substringBeforeLast(videoPath, "/");
                Resource resource = resolver.getResource(basePath);
                if (resource != null) {
                    for (Resource child : resource.getChildren()) {
                        if ("thumbnail".equals(child.getName())) {
                            String thumbnailPath = child.getValueMap().get("fileReference", "");
                            videoElement.appendElement("img")
                                    .attr("src", thumbnailPath)
                                    .attr("style", "width:100%; height:auto;");
                        }
                    }
                }
            } catch (Exception e) {
                LOG.error("Error updating video component references: {}", e.getMessage(), e);
            }
        }
    }

    // Method 6: Update Movie Component References
    private static void updateMovieComponentReferences(Document document) {
        Elements movieElements = document.select("div.movie-component");
        for (Element movieElement : movieElements) {
            Element videoTag = movieElement.selectFirst("video");
            if (videoTag != null) {
                Element sourceTag = videoTag.selectFirst("source");
                if (sourceTag != null) {
                    try {
                        String videoSrc = URLDecoder.decode(sourceTag.attr("src"), UTF_8_STRING);
                        sourceTag.attr("src", "/media/" + StringUtils.substringAfterLast(videoSrc, "/"));
                    } catch (UnsupportedEncodingException e) {
                        LOG.error("Error updating movie component references: {}", e.getMessage(), e);
                    }
                }
            }
        }
    }

    // Method 7: Add Image Style
    private static void addImageStyle(ResourceResolver resolver, Document document) {
        Elements imageElements = document.select("img");
        for (Element img : imageElements) {
            try {
                String imgSrc = URLDecoder.decode(img.attr("src"), UTF_8_STRING);
                Resource imageResource = resolver.getResource(imgSrc);
                if (imageResource != null) {
                    img.attr("src", "/media/" + StringUtils.substringAfterLast(imgSrc, "/"))
                       .attr("style", "max-width:100%; height:auto;");
                }
            } catch (Exception e) {
                LOG.error("Error adding image style: {}", e.getMessage(), e);
            }
        }
    }

    // Method 8: Add Anchor Link Style
    private static void addAnchorLinkStyle(Document document, SlingHttpServletRequest request) {
        String domainName = getDomain(request);
        document.select("a[href]").forEach(link -> {
            try {
                String href = URLDecoder.decode(link.attr("href"), UTF_8_STRING);
                if (domainName != null && href.startsWith(CONTENT_NODE)) {
                    link.attr("href", domainName + href);
                }
            } catch (UnsupportedEncodingException e) {
                LOG.error("Error decoding URL '{}': {}", link.attr("href"), e.getMessage(), e);
            }
        });
    }

    // Method 9: Get Domain
    public static String getDomain(SlingHttpServletRequest request) {
        Resource resource = request.getResource();
        ValueMap properties = resource.adaptTo(ValueMap.class);
        String domain = properties.get(PROP_CONF_DOMAIN, "");
        if (StringUtils.isBlank(domain)) {
            String pageURL = request.getRequestURL().toString();
            domain = StringUtils.substringBefore(pageURL, CONTENT_NODE);
        }
        return domain;
    }

    // Method 10: Copy Media Stream
    public static void copyMediaStream(ZipOutputStream zipOutputStream, String childNodeUrl, List<String> assets,
                                       Asset asset) throws IOException {
        try (InputStream mediaInputStream = asset.getOriginal().getStream()) {
            zipOutputStream.putNextEntry(new ZipEntry(childNodeUrl + asset.getName()));
            byte[] buffer = new byte[1024];
            int length;
            while ((length = mediaInputStream.read(buffer)) > 0) {
                zipOutputStream.write(buffer, 0, length);
            }
            assets.add(asset.getName());
        } catch (IOException e) {
            LOG.error("Error creating folders inside zip '{}': {}", e.getMessage(), e);
        } finally {
            zipOutputStream.closeEntry();
        }
    }
}



